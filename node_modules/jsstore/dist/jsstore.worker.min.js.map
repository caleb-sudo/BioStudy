{"version":3,"file":"jsstore.worker.min.js","mappings":"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","sources":["webpack://JsStoreWorker/webpack/bootstrap","webpack://JsStoreWorker/webpack/runtime/define property getters","webpack://JsStoreWorker/webpack/runtime/hasOwnProperty shorthand","webpack://JsStoreWorker/webpack/runtime/make namespace object","webpack://JsStoreWorker/./src/common/utils/promise_resolve.ts","webpack://JsStoreWorker/./src/common/enums.ts","webpack://JsStoreWorker/./src/common/utils/promise.ts","webpack://JsStoreWorker/./src/worker/model/table_meta.ts","webpack://JsStoreWorker/./src/worker/meta_helper.ts","webpack://JsStoreWorker/./src/worker/model/db_meta.ts","webpack://JsStoreWorker/./src/common/utils/for_obj.ts","webpack://JsStoreWorker/./src/worker/utils/log_helper.ts","webpack://JsStoreWorker/./src/worker/idbutil/index.ts","webpack://JsStoreWorker/./src/common/utils/promise_all.ts","webpack://JsStoreWorker/./src/worker/utils/promise_reject.ts","webpack://JsStoreWorker/./src/worker/utils/get_error.ts","webpack://JsStoreWorker/./src/worker/executors/base.ts","webpack://JsStoreWorker/./src/worker/utils/get_error_from_exception.ts","webpack://JsStoreWorker/./src/worker/utils/get_data_type.ts","webpack://JsStoreWorker/./src/worker/utils/is_null.ts","webpack://JsStoreWorker/./src/worker/executors/insert/values_checker.ts","webpack://JsStoreWorker/./src/worker/executors/update/schema_checker.ts","webpack://JsStoreWorker/./src/worker/executors/query_helper.ts","webpack://JsStoreWorker/./src/worker/executors/insert/index.ts","webpack://JsStoreWorker/./src/worker/constants/index.ts","webpack://JsStoreWorker/./src/worker/utils/set_cross_browser_idb.ts","webpack://JsStoreWorker/./src/worker/utils/is_array.ts","webpack://JsStoreWorker/./src/worker/utils/get_keys.ts","webpack://JsStoreWorker/./src/worker/utils/get_length.ts","webpack://JsStoreWorker/./src/worker/executors/select/then_evaluator.ts","webpack://JsStoreWorker/./src/worker/executors/select/where.ts","webpack://JsStoreWorker/./src/worker/executors/select/not_where.ts","webpack://JsStoreWorker/./src/worker/utils/remove_space.ts","webpack://JsStoreWorker/./src/worker/executors/select/order_by.ts","webpack://JsStoreWorker/./src/worker/utils/get_object_first_key.ts","webpack://JsStoreWorker/./src/worker/utils/get_regex_from_like.ts","webpack://JsStoreWorker/./src/worker/utils/clone.ts","webpack://JsStoreWorker/./src/worker/utils/compare.ts","webpack://JsStoreWorker/./src/worker/executors/where_checker.ts","webpack://JsStoreWorker/./src/worker/executors/base_fetch.ts","webpack://JsStoreWorker/./src/worker/executors/select/regex.ts","webpack://JsStoreWorker/./src/worker/executors/select/join.ts","webpack://JsStoreWorker/./src/worker/memory_store/index.ts","webpack://JsStoreWorker/./src/worker/executors/select/index.ts","webpack://JsStoreWorker/./src/worker/utils/is_object.ts","webpack://JsStoreWorker/./src/worker/executors/count/is_where_keys_length_one.ts","webpack://JsStoreWorker/./src/worker/executors/select/in.ts","webpack://JsStoreWorker/./src/worker/executors/select/base_select.ts","webpack://JsStoreWorker/./src/worker/executors/select/group_by.ts","webpack://JsStoreWorker/./src/worker/executors/count/where.ts","webpack://JsStoreWorker/./src/worker/executors/count/index.ts","webpack://JsStoreWorker/./src/worker/executors/count/not_where.ts","webpack://JsStoreWorker/./src/worker/executors/count/regex.ts","webpack://JsStoreWorker/./src/worker/executors/count/in.ts","webpack://JsStoreWorker/./src/worker/utils/resolve.ts","webpack://JsStoreWorker/./src/worker/executors/update/update_value.ts","webpack://JsStoreWorker/./src/worker/executors/update/index.ts","webpack://JsStoreWorker/./src/worker/executors/update/not_where.ts","webpack://JsStoreWorker/./src/worker/executors/update/where.ts","webpack://JsStoreWorker/./src/worker/executors/update/regex.ts","webpack://JsStoreWorker/./src/worker/executors/update/in.ts","webpack://JsStoreWorker/./src/worker/intersect/index.ts","webpack://JsStoreWorker/./src/worker/executors/drop_db.ts","webpack://JsStoreWorker/./src/worker/union/index.ts","webpack://JsStoreWorker/./src/worker/executors/remove/where.ts","webpack://JsStoreWorker/./src/worker/executors/remove/index.ts","webpack://JsStoreWorker/./src/worker/executors/remove/in.ts","webpack://JsStoreWorker/./src/worker/executors/remove/not_where.ts","webpack://JsStoreWorker/./src/worker/executors/remove/regex.ts","webpack://JsStoreWorker/./src/worker/executors/clear/index.ts","webpack://JsStoreWorker/./src/worker/executors/transaction/index.ts","webpack://JsStoreWorker/./src/worker/utils/db_schema.ts","webpack://JsStoreWorker/./src/worker/query_manager.ts","webpack://JsStoreWorker/./src/worker/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export const promiseResolve = (value?) => {\n    return Promise.resolve(value);\n}","export const ERROR_TYPE = {\n    InvalidUpdateColumn: \"invalid_update_column\",\n    UndefinedColumn: \"undefined_column\",\n    UndefinedValue: \"undefined_value\",\n    UndefinedColumnName: \"undefined_column_name\",\n    UndefinedDbName: \"undefined_database_name\",\n    UndefinedColumnValue: \"undefined_column_value\",\n    NotArray: \"not_array\",\n    NoValueSupplied: \"no_value_supplied\",\n    ColumnNotExist: \"column_not_exist\",\n    NoIndexFound: \"no_index_found\",\n    InvalidOp: \"invalid_operator\",\n    NullValue: \"null_value\",\n    WrongDataType: \"wrong_data_type\",\n    TableNotExist: \"table_not_exist\",\n    DbNotExist: \"db_not_exist\",\n    ConnectionAborted: \"connection_aborted\",\n    ConnectionClosed: \"connection_closed\",\n    NotObject: \"not_object\",\n    InvalidConfig: \"invalid_config\",\n    DbBlocked: \"Db_blocked\",\n    IndexedDbNotSupported: \"indexeddb_not_supported\",\n    NullValueInWhere: \"null_value_in_where\",\n    InvalidJoinQuery: 'invalid_join_query',\n    InvalidQuery: 'invalid_query',\n    ImportScriptsFailed: 'import_scripts_failed',\n    MethodNotExist: 'method_not_exist',\n    Unknown: \"unknown\",\n    InvalidMiddleware: \"invalid_middleware\",\n    InvalidOrderQuery: 'invalid_order_query',\n    InvalidGroupQuery: 'invalid_group_query',\n    NoPrimaryKey: 'no_primary_key'\n};\n\nexport enum WORKER_STATUS {\n    Registered = \"registerd\",\n    Failed = \"failed\",\n    NotStarted = \"not_started\"\n}\n\nexport enum DATA_TYPE {\n    String = \"string\",\n    Object = \"object\",\n    Array = \"array\",\n    Number = \"number\",\n    Boolean = \"boolean\",\n    Null = \"null\",\n    DateTime = \"date_time\"\n}\n\n\nexport enum API {\n    InitDb = \"init_db\",\n    MapGet = \"map_get\",\n    MapSet = \"map_set\",\n    MapHas = \"map_has\",\n    MapDelete = \"map_delete\",\n    Select = \"select\",\n    Insert = \"insert\",\n    Update = \"update\",\n    Remove = \"remove\",\n    OpenDb = \"open_db\",\n    Clear = \"clear\",\n    DropDb = \"drop_db\",\n    Count = \"count\",\n    ChangeLogStatus = \"change_log_status\",\n    Terminate = \"terminate\",\n    Transaction = \"transaction\",\n    CloseDb = \"close_db\",\n    Union = \"union\",\n    Intersect = \"intersect\",\n    ImportScripts = \"import_scripts\",\n    Middleware = \"middleware\"\n}\n\nexport enum EVENT {\n    RequestQueueEmpty = \"requestQueueEmpty\",\n    RequestQueueFilled = \"requestQueueFilled\",\n    Upgrade = \"upgrade\",\n    Create = \"create\",\n    Open = \"open\"\n}\n\nexport enum QUERY_OPTION {\n    Where = \"where\",\n    Like = 'like',\n    Regex = 'regex',\n    In = 'in',\n    Equal = \"=\",\n    Between = '-',\n    GreaterThan = '>',\n    LessThan = '<',\n    GreaterThanEqualTo = \">=\",\n    LessThanEqualTo = \"<=\",\n    NotEqualTo = \"!=\",\n    Aggregate = \"aggregate\",\n    Max = \"max\",\n    Min = \"min\",\n    Avg = \"avg\",\n    Count = \"count\",\n    Sum = \"sum\",\n    List = \"list\",\n    Or = \"or\",\n    Skip = \"skip\",\n    Limit = \"limit\",\n    And = \"and\",\n    IgnoreCase = \"ignoreCase\",\n    Then = \"then\"\n}\n\nexport enum IDB_MODE {\n    ReadOnly = \"readonly\",\n    ReadWrite = \"readwrite\"\n}\n\nexport enum OCCURENCE {\n    First = 'f',\n    Last = 'l',\n    Any = 'a'\n}\n\nexport enum CONNECTION_STATUS {\n    Connected = \"connected\",\n    Closed = \"closed\",\n    NotStarted = \"not_started\",\n    UnableToStart = \"unable_to_start\",\n    ClosedByJsStore = \"closed_by_jsstore\"\n}\n","export const promise = <T>(cb: (res, rej?) => any) => {\n    return new Promise<T>(cb);\n}","import { ITable, IAlterQuery, IColumn, TColumns } from \"@/common\";\n\nexport class TableMeta {\n    name: string;\n    columns: IColumn[] = [];\n    primaryKey: string;\n    autoIncColumnValue = {};\n    alter?: IAlterQuery;\n    keypath: string | string[];\n\n    constructor(table: ITable) {\n        this.columns = this.setColumn(table.columns);\n        this.name = table.name;\n        this.alter = table.alter || {};\n    }\n\n    setColumn(tableColumns: TColumns) {\n        const columns = [];\n        for (const columnName in tableColumns) {\n            const column: IColumn = tableColumns[columnName] as any;\n            column.name = columnName;\n            if (column.autoIncrement) {\n                this.autoIncColumnValue[columnName] = 0;\n            }\n            if (column.primaryKey) {\n                this.primaryKey = columnName;\n                this.keypath = column.keyPath || columnName;\n            }\n            column.enableSearch = column.enableSearch == null ? true : column.enableSearch;\n            const existingColumnIndex = this.columns.indexOf(q => q.name === columnName);\n            if (existingColumnIndex < 0) {\n                columns.push(column);\n            }\n            else {\n                const existingColumn = this.columns[existingColumnIndex];\n                Object.assign(existingColumn, column);\n            }\n        }\n        return columns;\n    }\n\n\n}\n","import { IDBUtil } from \"@/worker/idbutil\";\nimport { promise } from \"@/common\";\n\nexport class MetaHelper {\n    static tableName = \"JsStore_Meta\";\n    static autoIncrementKey(tableName: string, columnName: string) {\n        return `JsStore_${tableName}_${columnName}_Value`;\n    }\n    static dbSchema = `JsStore_DbSchema`;\n\n    static getStore(util: IDBUtil) {\n        if (!util.tx) {\n            util.createTransaction([MetaHelper.tableName]);\n        }\n        return util.objectStore(MetaHelper.tableName);\n    }\n\n    static set(key, value, util: IDBUtil) {\n        const store = MetaHelper.getStore(util);\n        return promise((res, rej) => {\n            const req = store.put({\n                key, value\n            });\n            req.onsuccess = () => {\n                res();\n            };\n            req.onerror = rej;\n        });\n    }\n\n    static get(key, util: IDBUtil) {\n        const store = MetaHelper.getStore(util);\n\n        return promise((res, rej) => {\n            const req = store.get(\n                util.keyRange(key)\n            );\n            req.onsuccess = () => {\n                const result = req.result;\n                res(result && result.value);\n            };\n            req.onerror = rej;\n        });\n    }\n\n    static remove(key, util: IDBUtil) {\n        const store = MetaHelper.getStore(util);\n\n        return promise((res, rej) => {\n            const req = store.delete(\n                util.keyRange(key)\n            );\n            req.onsuccess = () => {\n                res();\n            };\n            req.onerror = rej;\n        });\n    }\n\n    static has(key, util: IDBUtil) {\n        const store = MetaHelper.getStore(util);\n\n        return promise((res, rej) => {\n            const req = store.count(\n                util.keyRange(key)\n            );\n            req.onsuccess = () => {\n                const result = req.result;\n                res(result > 0);\n            };\n            req.onerror = rej;\n        });\n    }\n}","import { IDataBase } from \"@/common\";\nimport { TableMeta } from \"./table_meta\";\nimport { MetaHelper } from \"@worker/meta_helper\";\n\nexport class DbMeta {\n    name: string;\n    version: number;\n    tables: TableMeta[];\n\n    constructor(db: IDataBase) {\n        this.name = db.name;\n        this.version = db.version || 1;\n        db.tables.push({\n            name: MetaHelper.tableName,\n            columns: {\n                key: {\n                    primaryKey: true\n                },\n                value: {\n                    enableSearch: false\n                }\n            },\n        })\n        this.tables = db.tables.map(table => {\n            return new TableMeta(table);\n        });\n    }\n}","export const forObj = (obj: object, cb: (key, value) => void) => {\n    for (const key in obj) {\n        cb(key, obj[key]);\n    }\n}","import { ERROR_TYPE, IError } from \"@/common\";\n\nexport class LogHelper implements IError {\n    type: string;\n    message: string;\n    private info_: any;\n\n    status: boolean;\n\n    log(msg) {\n        if (this.status) {\n            console.log(msg);\n        }\n    }\n\n    constructor(type: string, info?) {\n        this.type = type;\n        this.info_ = info;\n        this.message = this.getMsg_();\n    }\n\n    throw() {\n        throw this.get();\n    }\n\n\n    logError() {\n        console.error(this.get());\n    }\n\n\n\n    get() {\n        return {\n            message: this.message,\n            type: this.type\n        } as IError;\n    }\n\n    warn() {\n        console.warn(this.get());\n    }\n\n    private getMsg_() {\n        let errMsg: string;\n        const info = this.info_;\n        const errorHandler = {\n            [ERROR_TYPE.NotArray]() {\n                errMsg = \"Supplied value is not an array\";\n            },\n            [ERROR_TYPE.UndefinedColumn]() {\n                errMsg = \"Column is undefined in Where\";\n            },\n            [ERROR_TYPE.UndefinedValue]() {\n                errMsg = \"Value is undefined in Where\";\n            },\n            [ERROR_TYPE.UndefinedColumnName]() {\n                errMsg = \"Column name is undefined '\" + info['TableName'] + \"'\";\n            },\n            [ERROR_TYPE.UndefinedDbName]() {\n                errMsg = \"Database name is not supplied\";\n            },\n            [ERROR_TYPE.UndefinedColumnValue]() {\n                errMsg = \"Column value is undefined\";\n            },\n            [ERROR_TYPE.NoValueSupplied]() {\n                errMsg = \"No value is supplied\";\n            },\n            [ERROR_TYPE.InvalidOp]() {\n                errMsg = \"Invalid Op Value '\" + info['Op'] + \"'\";\n            },\n            [ERROR_TYPE.ColumnNotExist]() {\n                const column = info['column'];\n                errMsg = info['isOrder'] ?\n                    (\n                        process.env.NODE_ENV !== 'production' && info.isJoin ?\n                            `Column '${column}' in order query is invalid. Please use '<table>.<column>' format for specifying a column in join query.` :\n                            `Column '${column}' in order query does not exist`\n                    ) :\n                    `Column '${column}' does not exist`;\n            },\n            [ERROR_TYPE.NoIndexFound]() {\n                errMsg = \"No index found for column '\" + info['column'] + \"'. Query can not be executed without index.\";\n            },\n            [ERROR_TYPE.NullValue]() {\n                errMsg = \"Null value is not allowed for column '\" + info['ColumnName'] + \"'\";\n            },\n            [ERROR_TYPE.WrongDataType]() {\n                errMsg = `Expected data type for the column ${info['column']} is ${info['expected']}, but received a ${info['received']}.`\n                // errMsg = \"Supplied value for column '\" + info['column'] +\n                //     \"' have wrong data type\";\n            },\n            [ERROR_TYPE.TableNotExist]() {\n                errMsg = \"Table '\" + info['tableName'] + \"' does not exist\";\n            },\n            [ERROR_TYPE.DbNotExist]() {\n                errMsg = `Database with name ${info['dbName']} does not exist`;\n            },\n            [ERROR_TYPE.NotObject]() {\n                errMsg = \"supplied value is not object\";\n            },\n            [ERROR_TYPE.InvalidConfig]() {\n                errMsg = \"Invalid Config '\" + info['Config'] + \" '\";\n            },\n            [ERROR_TYPE.DbBlocked]() {\n                errMsg = `database is blocked, cant be deleted right now`;\n            },\n            [ERROR_TYPE.NullValueInWhere]() {\n                errMsg = `Null/undefined is not allowed in where. Column '${info['column']}' has null`;\n            },\n            [ERROR_TYPE.MethodNotExist]() {\n                errMsg = `method '${info}' does not exist.`;\n            },\n            [ERROR_TYPE.IndexedDbNotSupported]() {\n                errMsg = \"Browser does not support indexeddb\";\n            },\n            getInfo() {\n                errMsg = info;\n            },\n            [ERROR_TYPE.InvalidJoinQuery]() {\n                errorHandler.getInfo();\n            },\n            [ERROR_TYPE.ImportScriptsFailed]() {\n                errorHandler.getInfo();\n            },\n            [ERROR_TYPE.InvalidMiddleware]() {\n                errMsg = `No function ${info} is found.`;\n            },\n        };\n        if (process.env.NODE_ENV !== 'production') {\n            Object.assign(errorHandler, {\n                [ERROR_TYPE.InvalidOrderQuery]() {\n                    errorHandler.getInfo();\n                },\n                [ERROR_TYPE.InvalidGroupQuery]() {\n                    errorHandler.getInfo();\n                },\n                [ERROR_TYPE.NoPrimaryKey]() {\n                    errMsg = `No primary key exists for the query table. The query ${JSON.stringify(info)} will not yield proper output.`\n                },\n            })\n        }\n        const errorType = this.type;\n        const method = errorHandler[errorType];\n        if (method) {\n            method();\n        }\n        else {\n            if (!errorType) {\n                this.type = ERROR_TYPE.Unknown\n            }\n            errMsg = this.message;\n        }\n        return errMsg;\n    }\n}\n","import { DbMeta, TableMeta } from \"@worker/model\";\nimport { IDB_MODE, QUERY_OPTION, promise, forObj, IColumn, InitDbResult } from \"@/common\";\nimport { LogHelper } from \"@worker/utils\";\n\nexport class IDBUtil {\n\n    db: DbMeta;\n\n    con: IDBDatabase;\n    tx: IDBTransaction;\n\n    logger = new LogHelper(null);\n\n    emptyTx() {\n        if (!this.tx) return;\n        this.tx.oncomplete = null;\n        this.tx.onabort = null;\n        this.tx.onerror = null;\n        this.tx = null;\n    }\n\n    createTransactionIfNotExist(tables: string[], mode?: IDB_MODE) {\n        if (!this.tx) {\n            this.createTransaction(tables, mode);\n        }\n    }\n\n    createTransaction(tables: string[], mode = IDB_MODE.ReadWrite) {\n        this.tx = this.con.transaction(tables, mode);\n        return promise<void>((res, rej) => {\n            this.tx.oncomplete = res;\n            this.tx.onabort = res;\n            this.tx.onerror = rej;\n        });\n    }\n\n    keyRange(value, op?) {\n        let keyRange: IDBKeyRange;\n        switch (op) {\n            case QUERY_OPTION.Between: keyRange = IDBKeyRange.bound(value.low, value.high, false, false); break;\n            case QUERY_OPTION.GreaterThan: keyRange = IDBKeyRange.lowerBound(value, true); break;\n            case QUERY_OPTION.GreaterThanEqualTo: keyRange = IDBKeyRange.lowerBound(value); break;\n            case QUERY_OPTION.LessThan: keyRange = IDBKeyRange.upperBound(value, true); break;\n            case QUERY_OPTION.LessThanEqualTo: keyRange = IDBKeyRange.upperBound(value); break;\n            default: keyRange = IDBKeyRange.only(value); break;\n        }\n        return keyRange;\n    }\n\n    objectStore(name: string) {\n        return this.tx.objectStore(name);\n    }\n\n    abortTransaction() {\n        if (this.tx) {\n            this.tx.abort();\n        }\n    }\n\n    close() {\n        if (this.con) {\n            this.con.close();\n        }\n        // wait for 100 ms before success\n        return promise(res => {\n            this.con = null;\n            setTimeout(res, 100);\n        });\n    }\n\n    initDb(db: DbMeta) {\n        let isDbCreated = false;\n        const dbVersion = db.version;\n        let oldVersion;\n        const initLogic = (res, rej) => {\n            const dbOpenRequest = indexedDB.open(db.name, dbVersion);\n            dbOpenRequest.onsuccess = () => {\n                this.con = dbOpenRequest.result;\n                this.con.onversionchange = (e: any) => {\n                    // if (e.newVersion === null) { // An attempt is made to delete the db\n                    e.target.close(); // Manually close our connection to the db\n                    // }\n                }\n\n                res({\n                    isCreated: isDbCreated,\n                    oldVersion: oldVersion,\n                    newVersion: dbVersion\n                } as InitDbResult);\n            }\n\n            dbOpenRequest.onerror = (e) => {\n                console.error(\"error\", e);\n                rej(e);\n            };\n\n            dbOpenRequest.onupgradeneeded = (e: IDBVersionChangeEvent) => {\n                oldVersion = e.oldVersion;\n                const target: {\n                    result: IDBDatabase,\n                    transaction: IDBTransaction\n                } = (e as any).target\n                const upgradeConnection = target.result;\n                isDbCreated = true;\n                const transaction = target.transaction;\n                const storeNames = upgradeConnection.objectStoreNames;\n                const createObjectStore = (table: TableMeta) => {\n                    const option: IDBObjectStoreParameters = table.primaryKey ? {\n                        keyPath: table.keypath,\n                    } : {\n                        autoIncrement: true\n                    }\n\n                    const store = upgradeConnection.createObjectStore(table.name, option);\n                    table.columns.forEach(column => {\n                        addColumn(store, column)\n                    });\n                }\n                const addColumn = (store: IDBObjectStore, column: IColumn) => {\n                    const columnName = column.name;\n                    if (column.enableSearch && !store.indexNames.contains(columnName)) {\n                        const options = column.primaryKey ? { unique: true } : { unique: column.unique };\n                        options['multiEntry'] = column.multiEntry;\n                        const keyPath = column.keyPath == null ? columnName : column.keyPath;\n                        store.createIndex(columnName, keyPath, options);\n                    }\n                }\n                const deleteColumn = (store: IDBObjectStore, table: TableMeta, columnName: string) => {\n                    const index = table.columns.findIndex(q => q.name === columnName);\n                    if (index >= 0) {\n                        table.columns.splice(index, 1);\n                        store.deleteIndex(columnName);\n                    }\n                }\n                db.tables.forEach(table => {\n                    if (!storeNames.contains(table.name)) {\n                        createObjectStore(table);\n                    }\n                    const store = transaction.objectStore(table.name);\n                    for (let i = oldVersion + 1; i <= dbVersion; i++) {\n                        const alterQuery = table.alter[i];\n                        if (alterQuery) {\n                            // handle new column add\n                            if (alterQuery.add) {\n                                const newColumns = table.setColumn(alterQuery.add);\n                                newColumns.forEach(column => {\n                                    addColumn(store, column);\n                                    table.columns.push(column);\n                                })\n                            }\n                            // handle delete column add\n                            forObj(\n                                alterQuery.drop || {}, ((columnName) => {\n                                    deleteColumn(store, table, columnName);\n                                })\n                            )\n                            // handle modify column\n                            forObj(\n                                alterQuery.modify || {}, ((columnName, column: IColumn) => {\n                                    const shouldDelete = column.multiEntry || column.keyPath || column.unique;\n                                    let targetColumn = table.columns.find(q => q.name === columnName);\n                                    const newColumn = Object.assign(targetColumn, column);\n                                    newColumn.name = columnName;\n                                    if (shouldDelete) {\n                                        deleteColumn(store, table, columnName);\n                                        addColumn(store, newColumn);\n                                        table.columns.push(newColumn);\n                                    }\n                                })\n                            )\n                        }\n                    }\n                });\n\n                for (let i = 0, length = storeNames.length; i < length; i++) {\n                    const storeName = storeNames.item(i);\n                    const tableIndex = db.tables.findIndex(qry => qry.name === storeName);\n                    if (tableIndex < 0) {\n                        upgradeConnection.deleteObjectStore(storeName);\n                    }\n                }\n\n            }\n        }\n        return promise<InitDbResult>(initLogic)\n    }\n}\n","export const promiseAll = <T>(promises: any) => {\n    return Promise.all<T>(promises);\n};","export const promiseReject = (value) => {\n    return Promise.reject(value);\n}","import { LogHelper } from \"./log_helper\";\n\nexport const getError = (e) => {\n    const customError = e instanceof LogHelper;\n    if (customError) {\n        e.logError();\n        return (e as LogHelper).get();\n    }\n    else {\n        let error;\n        if (e.name) {\n            error = new LogHelper(e.name);\n            error.message = e.message;\n        }\n        else {\n            error = new LogHelper((e as any).target.error.name);\n            error.message = (e as any).target.error.message;\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            error.logError();\n        }\n        return error.get();\n    }\n}","import { IDBUtil } from \"@worker/idbutil\";\nimport { IInsertQuery, ISelectQuery, IUpdateQuery } from \"@/common\";\nimport { promiseReject, getErrorFromException } from \"@worker/utils\";\n\nexport class Base {\n\n    get db() {\n        return this.util.db;\n    }\n\n    util: IDBUtil;\n    query: IInsertQuery | ISelectQuery | IUpdateQuery;\n\n    rowAffected = 0;\n    isTxQuery = false;\n    objectStore: IDBObjectStore;\n    tableName: string;\n\n    protected results: any[] = [];\n\n    table(name?: string) {\n        const tableName = name || this.tableName;\n        const table = this.db.tables.find(q => q.name === tableName);\n        if (process.env.NODE_ENV !== 'production') {\n            if (!table) {\n                console.warn(`No table found with name ${tableName}`);\n            }\n        }\n        return table;\n    }\n\n    primaryKey(tableName?: string) {\n        const query = this.query as ISelectQuery;\n        if (!query.from && query.store && query.meta) {\n            const primaryKey = query.meta.primaryKey;\n            if (process.env.NODE_ENV !== 'production') {\n                if (primaryKey == null) {\n                    delete query.store;\n                    console.warn(`no primary key found for query - ${JSON.stringify(this.query)}`);\n                }\n            }\n            return primaryKey;\n        }\n        const table = this.table(tableName);\n        if (process.env.NODE_ENV !== 'production') {\n            if (table == null && query.store) {\n                delete query.store;\n                const metaValue = query.meta;\n                if (!metaValue || !metaValue.primaryKey) {\n                    console.warn(`no primary key found for query - ${JSON.stringify(this.query)}. Please supply primary key in meta field.`);\n                }\n            }\n        }\n        return table.primaryKey;\n    }\n\n\n    protected getColumnInfo(columnName: string, tableName?: string) {\n        return this.table(tableName).columns.find(column => column.name === columnName);\n    }\n\n\n\n    onException(ex: DOMException, type?) {\n        console.error(ex);\n        this.util.abortTransaction();\n        return promiseReject(\n            getErrorFromException(ex, type)\n        );\n    }\n}\n","import { ERROR_TYPE } from \"@/common\"\nimport { getError } from \"./get_error\";\n\nexport const getErrorFromException = (ex, type = ERROR_TYPE.InvalidQuery) => {\n    ex.name = type;\n    return getError(ex);\n}","import { DATA_TYPE } from \"@/common\";\n\nexport const getDataType = (value) => {\n    if (value == null) {\n        return DATA_TYPE.Null;\n    }\n    const type = typeof value;\n    switch (type) {\n        case 'object':\n            if (Array.isArray(value)) {\n                return DATA_TYPE.Array;\n            }\n            if (value instanceof Date) {\n                return DATA_TYPE.DateTime;\n            }\n    }\n    return type;\n}","export const isNull = (value) => {\n    if (value == null) {\n        return true;\n    } else {\n        switch (typeof value) {\n            // case 'string': return value.length === 0;\n            case 'number': return isNaN(value);\n        }\n    }\n    return false;\n};","import { TableMeta } from \"@/worker/model/table_meta\";\nimport { IColumn, TStringAny, ERROR_TYPE, DATA_TYPE, IInsertQuery } from \"@/common\";\nimport { getDataType, LogHelper, isNull } from \"@/worker/utils\";\n\n\nexport class ValuesChecker {\n    table: TableMeta;\n    autoIncrementValue;\n    query: IInsertQuery;\n\n    constructor(table: TableMeta, autoIncValues) {\n        this.table = table;\n        this.autoIncrementValue = autoIncValues;\n    }\n\n    checkAndModifyValues(query: IInsertQuery) {\n        let err: LogHelper;\n        this.query = query;\n        const values = query.values;\n        const ignoreIndexes = [];\n        values.every((item, index) => {\n            err = this.checkAndModifyValue(item);\n            if (query.ignore && err) {\n                ignoreIndexes.push(index);\n                err = null;\n            }\n            return err ? false : true;\n        });\n        ignoreIndexes.forEach(index => {\n            values.splice(index, 1);\n        });\n        return { err, values };\n    }\n\n    private checkAndModifyValue(value) {\n        let error: LogHelper;\n        this.table.columns.every(column => {\n            error = this.checkAndModifyColumnValue_(column, value);\n            return error ? false : true;\n        })\n        return error;\n    }\n\n    private checkNotNullAndDataType_(column: IColumn, value: TStringAny) {\n        // check not null schema\n        if (column.notNull && isNull(value[column.name])) {\n            return this.getError(ERROR_TYPE.NullValue, { ColumnName: column.name });\n        }\n        // check datatype\n        else if (column.dataType && !isNull(value[column.name])) {\n            const receivedType = getDataType(value[column.name]);\n            if (receivedType !== column.dataType) {\n                return this.getError(ERROR_TYPE.WrongDataType, { column: column.name, expected: column.dataType, received: receivedType });\n            }\n        }\n    }\n\n    private checkAndModifyColumnValue_(column: IColumn, value: TStringAny) {\n        const columnValue = value[column.name];\n        // check auto increment scheme\n        if (column.autoIncrement) {\n            // if value is null, then create the autoincrement value\n            if (isNull(columnValue)) {\n                value[column.name] = ++this.autoIncrementValue[column.name];\n            }\n            else {\n                if (getDataType(columnValue) === DATA_TYPE.Number) {\n                    // if column value is greater than autoincrement value saved, then make the\n                    // column value as autoIncrement value\n                    if (columnValue > this.autoIncrementValue[column.name]) {\n                        this.autoIncrementValue[column.name] = columnValue;\n                    }\n                }\n            }\n        }\n        // check Default Schema\n        else if (column.default !== undefined && isNull(columnValue)) {\n            value[column.name] = column.default;\n        }\n        const query = this.query;\n        if (query.validation) {\n            return this.checkNotNullAndDataType_(column, value);\n        }\n    }\n\n    private getError(error: string, details: object) {\n        return new LogHelper(error, details);\n    }\n}\n","import { IColumn, DATA_TYPE, ERROR_TYPE } from \"@/common\";\nimport { LogHelper, isNull, getDataType } from \"@worker/utils\";\nimport { TableMeta } from \"@worker/model\";\n\nexport class SchemaChecker {\n    table: TableMeta;\n    constructor(table: TableMeta) {\n        this.table = table;\n    }\n\n    check(setValue: object, tblName: string) {\n        let log: LogHelper;\n        if (typeof setValue === DATA_TYPE.Object) {\n            if (this.table) {\n                // loop through table column and find data is valid\n                this.table.columns.every((column) => {\n                    if (column.name in setValue) {\n                        log = this.checkByColumn_(column, setValue[column.name]);\n                    }\n                    return log ? false : true;\n                });\n            }\n            else {\n                log = new LogHelper(ERROR_TYPE.TableNotExist, { tableName: tblName });\n            }\n        }\n        else {\n            log = new LogHelper(ERROR_TYPE.NotObject);\n        }\n        return log;\n    }\n\n\n\n    private checkByColumn_(column: IColumn, value) {\n        // check not null schema\n        if (column.notNull === true && isNull(value)) {\n            return new LogHelper(ERROR_TYPE.NullValue, { ColumnName: column.name });\n        }\n\n        // check datatype\n        const type = getDataType(value);\n        const checkFurther = value != null;\n        if (column.dataType && checkFurther) {\n            if (type !== column.dataType && type !== 'object') {\n                return new LogHelper(ERROR_TYPE.WrongDataType, { column: column.name, expected: column.dataType, received: type });\n            }\n        }\n\n        // check allowed operators\n        if (checkFurther && type === 'object') {\n            const allowedOp = ['+', '-', '*', '/', '{push}'];\n            for (const prop in value) {\n                if (allowedOp.indexOf(prop) < 0 && column.dataType && type !== column.dataType) {\n                    return new LogHelper(ERROR_TYPE.WrongDataType, { column: column.name, expected: column.dataType, received: type });\n                }\n            }\n        }\n    }\n}\n","import { IInsertQuery, DATA_TYPE, ERROR_TYPE, ISelectQuery, QUERY_OPTION, IUpdateQuery, API } from \"@/common\";\nimport { LogHelper, getDataType } from \"@/worker/utils\";\nimport { DbMeta } from \"../model\";\nimport { ValuesChecker } from \"@worker/executors/insert\";\nimport { SchemaChecker } from \"./update/schema_checker\";\n\nexport class QueryHelper {\n    db: DbMeta;\n\n    constructor(dbSchema: DbMeta) {\n        this.db = dbSchema;\n    }\n\n    validate(api: API, query: IInsertQuery | ISelectQuery | IUpdateQuery) {\n        switch (api) {\n            case API.Select:\n            case API.Remove:\n            case API.Count:\n                return this.checkSelect(query as ISelectQuery);\n            case API.Insert:\n                return this.checkInsertQuery(query as IInsertQuery);\n            case API.Update:\n                return this.checkUpdate(query as IUpdateQuery);\n        }\n    }\n\n    private getTable_(tableName: string) {\n        return this.db.tables.find(q => q.name === tableName);\n    }\n\n    isInsertQryValid(query: IInsertQuery) {\n        const table = this.getTable_(query.into);\n        let log: LogHelper;\n        if (table) {\n            switch (getDataType(query.values)) {\n                case DATA_TYPE.Array:\n                    break;\n                case DATA_TYPE.Null:\n                    log = new LogHelper(ERROR_TYPE.NoValueSupplied);\n                    break;\n                default:\n                    log = new LogHelper(ERROR_TYPE.NotArray);\n            }\n        }\n        else {\n            log = new LogHelper(ERROR_TYPE.TableNotExist, { tableName: query.into });\n        }\n        return {\n            table, log\n        };\n    }\n\n    private checkUpdate(query: IUpdateQuery) {\n        let err = new SchemaChecker(this.getTable_(query.in)).\n            check(query.set, query.in);\n        if (err) return err;\n        if (query.where != null) {\n            err = this.checkForNullInWhere_(query);\n            if (err) return err;\n            this.addGreatAndLessToNotOp_(query as any);\n        }\n    }\n\n    private checkSelect(query: ISelectQuery) {\n        if (!query.store) {\n            const table = this.getTable_(query.from);\n            if (!table) {\n                return new LogHelper(ERROR_TYPE.TableNotExist,\n                    { tableName: query.from }\n                );\n            }\n        }\n\n        if (query.where) {\n            const err = this.checkForNullInWhere_(query);\n            if (err) return err;\n            this.addGreatAndLessToNotOp_(query);\n        }\n    }\n\n    private checkForNullInWhere_(query): LogHelper {\n        for (const columnName in query.where) {\n            if (query.where[columnName] == null) {\n                return new LogHelper(ERROR_TYPE.NullValueInWhere, { column: columnName });\n            }\n        }\n    }\n\n    private addGreatAndLessToNotOp_(query: ISelectQuery) {\n        const whereQuery = query.where;\n        const containsNot = (qry: object, keys: string[]) => {\n            return keys.findIndex(key => qry[key][QUERY_OPTION.NotEqualTo] != null) >= 0;\n        };\n        const addToSingleQry = (qry, keys: string[]) => {\n            let value;\n            keys.forEach((prop) => {\n                value = qry[prop];\n                if (value[QUERY_OPTION.NotEqualTo] != null) {\n                    qry[prop][QUERY_OPTION.GreaterThan] = value[QUERY_OPTION.NotEqualTo];\n                    if (qry[QUERY_OPTION.Or] === undefined) {\n                        qry[QUERY_OPTION.Or] = {};\n                        qry[QUERY_OPTION.Or][prop] = {};\n                    }\n                    else if (qry[QUERY_OPTION.Or][prop] === undefined) {\n                        qry[QUERY_OPTION.Or][prop] = {};\n                    }\n                    qry[QUERY_OPTION.Or][prop][QUERY_OPTION.LessThan] = value[QUERY_OPTION.NotEqualTo];\n                    delete qry[prop][QUERY_OPTION.NotEqualTo];\n                }\n            });\n            return qry;\n        };\n        switch (getDataType(whereQuery)) {\n            case DATA_TYPE.Object:\n                const queryKeys = Object.keys(whereQuery);\n                if (containsNot(whereQuery, queryKeys)) {\n                    if (queryKeys.length === 1) {\n                        query.where = addToSingleQry(whereQuery, queryKeys);\n                    }\n                    else {\n                        const whereTmpQry = [];\n                        queryKeys.forEach((prop) => {\n                            whereTmpQry.push(addToSingleQry({ [prop]: whereQuery[prop] }, [prop]));\n                        });\n                        query.where = whereTmpQry;\n                    }\n                }\n                break;\n            default:\n                const whereTmp = [];\n                (whereQuery as object[]).forEach(qry => {\n                    const qryKeys = Object.keys(qry);\n                    if (containsNot(qry, qryKeys)) {\n                        qry = addToSingleQry(qry, qryKeys);\n                    }\n                    whereTmp.push(qry);\n                });\n                query.where = whereTmp;\n        }\n    }\n\n    private checkInsertQuery(query: IInsertQuery) {\n        const validResult = this.isInsertQryValid(query);\n        let table = validResult.table;\n        const error = validResult.log;\n        if (error) return error;\n        if (query.skipDataCheck) return;\n        const valueCheckerInstance = new ValuesChecker(table, table.autoIncColumnValue);\n        const { values, err } = valueCheckerInstance.checkAndModifyValues(query);\n        query.values = values;\n        return err;\n    }\n}","export * from \"./values_checker\";\nimport { IInsertQuery, promise, promiseAll, API, IDB_MODE } from \"@/common\";\nimport { Base } from \"@worker/executors/base\";\nimport { IDBUtil } from \"@/worker/idbutil\";\nimport { QueryHelper } from \"@worker/executors/query_helper\";\nimport { DbMeta } from \"@/worker/model\";\nimport { promiseReject } from \"@/worker/utils\";\nimport { MetaHelper } from \"@/worker/meta_helper\";\n\nexport class Insert extends Base {\n\n    query: IInsertQuery;\n\n    private valuesAffected_ = [];\n\n    constructor(query: IInsertQuery, util: IDBUtil) {\n        super();\n        if (query.validation == null) {\n            query.validation = true;\n        }\n        this.query = query;\n        this.util = util;\n        this.tableName = query.into;\n    }\n\n    execute(beforeInsert: () => Promise<any>) {\n        const db = this.db;\n        const err = new QueryHelper(db).validate(API.Insert, this.query);\n        if (err) return promiseReject(err);\n\n        return beforeInsert().then(_ => {\n            return this.insertData_(db).then(_ => {\n                return this.query.return ? this.valuesAffected_ : this.rowAffected\n            })\n        }).catch(err => {\n            this.util.abortTransaction();\n            return promiseReject(err);\n        })\n    }\n\n    private insertData_(db: DbMeta) {\n\n        let onInsertData;\n        let addMethod;\n\n        const query = this.query;\n        if (query.return) {\n            onInsertData = (value) => {\n                this.valuesAffected_.push(value);\n            };\n\n        }\n        else {\n            onInsertData = (value) => {\n                ++this.rowAffected;\n            };\n        }\n        addMethod = (() => {\n            const idbMethod = query.upsert ? \"put\" : \"add\";\n            if (query.ignore && !this.isTxQuery) {\n                return (value) => {\n                    const tx = this.util.con.transaction(query.into, IDB_MODE.ReadWrite);\n                    const objectStore = tx.objectStore(query.into);\n                    return objectStore[idbMethod](value);\n                };\n            }\n            if (!this.isTxQuery) {\n                this.util.createTransaction(\n                    [query.into, MetaHelper.tableName],\n                )\n            }\n            this.objectStore = this.util.objectStore(this.tableName);\n            return (value) => {\n                return this.objectStore[idbMethod](value);\n            };\n        })();\n\n        return promiseAll(\n            query.values.map((value) => {\n                return promise((res, rej) => {\n                    const addResult = addMethod(value);\n                    addResult.onerror = (err) => {\n                        if (query.ignore) {\n                            res();\n                        } else {\n                            rej(err);\n                        }\n                    }\n                    addResult.onsuccess = function () {\n                        onInsertData(value);\n                        res();\n                    };\n                });\n            })\n        ).then(() => {\n            return MetaHelper.set(MetaHelper.dbSchema, db, this.util);\n        });\n    }\n}","import { setCrossBrowserIndexedDb } from \"@worker/utils\";\n\nexport const IS_WORKER = typeof (self as any).alert === 'undefined' && typeof ServiceWorkerGlobalScope === 'undefined';\nexport const IS_IDB_SUPPORTED = setCrossBrowserIndexedDb();","export const setCrossBrowserIndexedDb = () => {\n    try {\n        if (!indexedDB) {\n            indexedDB = (self as any).mozIndexedDB ||\n                (self as any).webkitIndexedDB || (self as any).msIndexedDB;\n        }\n        if (indexedDB) {\n            IDBTransaction = IDBTransaction ||\n                (self as any).webkitIDBTransaction || (self as any).msIDBTransaction;\n            (self as any).IDBKeyRange = (self as any).IDBKeyRange ||\n                (self as any).webkitIDBKeyRange || (self as any).msIDBKeyRange;\n        }\n        else {\n            return false;\n        }\n    } catch (ex) {\n        return false;\n    }\n    return true;\n};","export const isArray = (value) => {\n    return Array.isArray(value);\n};","export const getKeys = (value) => {\n    return Object.keys(value);\n};","import { getKeys } from \"./get_keys\"\n\nexport const getLength = (value): number => {\n    return getKeys(value).length;\n}","import { ICaseOption, QUERY_OPTION } from \"@/common\";\n\nexport class ThenEvaluator {\n    private columnName_: string;\n    private value;\n    private caseQuery_: { [columnName: string]: [ICaseOption] };\n    private caseColumnQuery_: ICaseOption[];\n    private length_: number;\n\n    setCaseAndValue(caseQuery: any, value) {\n        this.caseQuery_ = caseQuery;\n        this.setValue(value);\n    }\n\n    setCaseAndColumn(caseQuery: { [columnName: string]: [ICaseOption] }, columnName: string) {\n        this.caseQuery_ = caseQuery;\n        this.setColumn(columnName);\n        return this;\n    }\n\n    setColumn(columnName: string) {\n        this.columnName_ = columnName;\n        this.caseColumnQuery_ = this.caseQuery_[this.columnName_];\n        this.length_ = this.caseColumnQuery_.length;\n        return this;\n    }\n\n    setValue(value) {\n        this.value = value;\n        return this;\n    }\n\n    evaluate() {\n        for (let i = 0; i < this.length_; i++) {\n            if (this.checkCase_(this.caseColumnQuery_[i]) === true) {\n                return this.caseColumnQuery_[i].then;\n            }\n        }\n        const lastThen = this.caseColumnQuery_[this.length_ - 1].then;\n        return lastThen == null ? this.value[this.columnName_] : lastThen;\n    }\n\n    private checkCase_(cond: ICaseOption) {\n        let queryOption;\n        for (queryOption in cond) {\n            switch (queryOption) {\n                case QUERY_OPTION.GreaterThan:\n                    if (this.value[this.columnName_] > cond[queryOption]) {\n                        return true;\n                    } break;\n                case QUERY_OPTION.Equal:\n                    if (this.value[this.columnName_] === cond[queryOption]) {\n                        return true;\n                    } break;\n                case QUERY_OPTION.LessThan:\n                    if (this.value[this.columnName_] < cond[queryOption]) {\n                        return true;\n                    } break;\n                case QUERY_OPTION.GreaterThanEqualTo:\n                    if (this.value[this.columnName_] >= cond[queryOption]) {\n                        return true;\n                    } break;\n                case QUERY_OPTION.LessThanEqualTo:\n                    if (this.value[this.columnName_] <= cond[queryOption]) {\n                        return true;\n                    } break;\n                case QUERY_OPTION.NotEqualTo:\n                    if (this.value[this.columnName_] !== cond[queryOption]) {\n                        return true;\n                    } break;\n                case QUERY_OPTION.Between:\n                    if (this.value[this.columnName_] > cond[queryOption].low && this.value[this.columnName_] < cond[queryOption].high) {\n                        return true;\n                    } break;\n            }\n            return false;\n        }\n    }\n}","import { Select } from \"./\";\nimport { promise } from \"@/common\";\nimport { BaseFetch } from \"../base_fetch\";\n\nexport const getCursorOnSuccess = function (this: Select, simpleFn, limitFn, skipFn, skipAndLimitFn) {\n    if (this.limitAtEnd === false && this.skipAtEnd === false) {\n        if (this.skipRecord) {\n            return this.limitRecord ? skipAndLimitFn : skipFn\n        }\n        if (this.limitRecord) {\n            return limitFn;\n        }\n    }\n    return simpleFn;\n}\n\nexport const executeWhereLogic = function (this: BaseFetch, column, value, op, dir) {\n\n    value = op ? value[op] : value;\n    const cursorRequest = this.objectStore.index(column).openCursor(\n        this.util.keyRange(value, op),\n        dir\n    );\n\n    const onSuccess = getCursorOnSuccess.call(\n        this,\n        executeSimpleForWhere_,\n        executeLimitForWhere_,\n        executeSkipForWhere_,\n        executeSkipAndLimitForWhere_\n    );\n\n    return promise<any>((res, rej) => {\n        cursorRequest.onerror = rej;\n        cursorRequest.onsuccess = onSuccess.call(this, res);\n    })\n\n}\n\nconst executeSkipAndLimitForWhere_ = function (this: Select, onFinish) {\n    let recordSkipped = false;\n    return (e: any) => {\n        const cursor: IDBCursorWithValue = e.target.result;\n        if (cursor) {\n            if (recordSkipped && this.results.length !== this.limitRecord) {\n                if (this.shouldAddValue(cursor)) {\n                    this.pushResult(cursor.value);\n                }\n                cursor.continue();\n            }\n            else {\n                recordSkipped = true;\n                cursor.advance(this.skipRecord);\n            }\n        }\n        else {\n            onFinish();\n        }\n    };\n}\n\nconst executeSkipForWhere_ = function (this: Select, onFinish) {\n    let recordSkipped = false;\n    return (e: any) => {\n        const cursor = e.target.result;\n        if (cursor) {\n            if (recordSkipped) {\n                if (this.shouldAddValue(cursor)) {\n                    this.pushResult(cursor.value);\n                }\n                cursor.continue();\n            }\n            else {\n                recordSkipped = true;\n                cursor.advance(this.skipRecord);\n            }\n        }\n        else {\n            onFinish();\n        }\n    };\n}\n\nexport const executeLimitForWhere_ = function (this: Select, onFinish) {\n    return (e: any) => {\n        const cursor = e.target.result;\n        if (cursor && this.results.length !== this.limitRecord) {\n            if (this.shouldAddValue(cursor)) {\n                this.pushResult(cursor.value);\n            }\n            cursor.continue();\n        }\n        else {\n            onFinish();\n        }\n    };\n\n}\n\nexport const executeSimpleForWhere_ = function (this: Select, onFinish) {\n    return (e: any) => {\n        const cursor: IDBCursorWithValue = e.target.result;\n        if (cursor) {\n            if (this.shouldAddValue(cursor)) {\n                this.pushResult(cursor.value);\n            }\n            cursor.continue();\n        }\n        else {\n            onFinish();\n        }\n    };\n}","import { Select } from \"./index\";\nimport { LogHelper, promiseReject } from \"@/worker/utils\";\nimport { ERROR_TYPE, IOrderQuery, promise, promiseResolve } from \"@/common\";\nimport { getCursorOnSuccess } from \"./where\";\n\nexport const executeWhereUndefinedLogic = function (this: Select) {\n    let cursorRequest: IDBRequest;\n    const query = this.query;\n    const store = query.store;\n    if (store) {\n        this.results = store as any[];\n        this.setLimitAndSkipEvaluationAtEnd_();\n        return promiseResolve();\n    }\n    const orderQuery = query.order;\n    const objectStore = this.objectStore;\n    if (orderQuery && (orderQuery as IOrderQuery).idbSorting !== false && (orderQuery as IOrderQuery).by) {\n        if (objectStore.indexNames.contains((orderQuery as IOrderQuery).by as string)) {\n            const orderType: IDBCursorDirection = (orderQuery as IOrderQuery).type &&\n                (orderQuery as IOrderQuery).type.toLowerCase() === 'desc' ? 'prev' : 'next';\n            this.sorted = true;\n            cursorRequest = objectStore.index((orderQuery as IOrderQuery).by as string).\n                openCursor(null, orderType);\n        }\n        else {\n            return promiseReject(\n                new LogHelper(\n                    ERROR_TYPE.ColumnNotExist,\n                    { column: (orderQuery as IOrderQuery).by, isOrder: true }\n                )\n            );\n        }\n    }\n    else {\n        cursorRequest = objectStore.openCursor();\n    }\n\n    const onSuccess = getCursorOnSuccess.call(\n        this,\n        executeSimple,\n        executeLimit,\n        executeSkip,\n        executeSkipAndLimit\n    );\n\n    return promise<void>((res, rej) => {\n        cursorRequest.onerror = rej;\n        cursorRequest.onsuccess = onSuccess.call(this, res);\n    });\n}\n\nconst executeSkipAndLimit = function (this: Select, onFinished) {\n    let recordSkipped = false,\n        cursor: IDBCursorWithValue;\n    return (e) => {\n        cursor = (e as any).target.result;\n        if (cursor) {\n            if (recordSkipped && this.results.length !== this.limitRecord) {\n                this.pushResult(cursor.value);\n                cursor.continue();\n            }\n            else {\n                recordSkipped = true;\n                cursor.advance(this.skipRecord);\n            }\n        } else {\n            onFinished();\n        }\n    };\n}\n\nconst executeSkip = function (this: Select, onFinished) {\n    let recordSkipped = false,\n        cursor;\n    return (e: any) => {\n        cursor = e.target.result;\n        if (cursor) {\n            if (recordSkipped) {\n                this.pushResult(cursor.value);\n                cursor.continue();\n            }\n            else {\n                recordSkipped = true;\n                cursor.advance(this.skipRecord);\n            }\n        } else {\n            onFinished();\n        }\n    };\n}\n\nconst executeSimple = function (this: Select, onFinished) {\n    let cursor;\n    return (e: any) => {\n        cursor = e.target.result;\n        if (cursor) {\n            this.pushResult(cursor.value);\n            (cursor as any).continue();\n        }\n        else {\n            onFinished();\n        }\n    };\n}\n\nconst executeLimit = function (this: Select, onFinished) {\n    let cursor;\n    return (e: any) => {\n        cursor = e.target.result;\n        if (cursor && this.results.length !== this.limitRecord) {\n            this.pushResult(cursor.value);\n            cursor.continue();\n        } else {\n            onFinished();\n        }\n    };\n}\n","export const removeSpace = (value: string) => {\n    return value.replace(/\\s/g, '');\n};","import { Select } from \"./\";\nimport { removeSpace, getDataType, LogHelper } from \"@/worker/utils\";\nimport { ERROR_TYPE, DATA_TYPE, ICaseOption, IColumn, IOrderQuery } from \"@/common\";\n\nexport const processGroupDistinctAggr = function (this: Select) {\n    const query = this.query;\n    if (query.distinct) {\n        const groupBy = [];\n        const result = this.results[0];\n        for (const key in result) {\n            groupBy.push(key);\n        }\n        const primaryKey = this.primaryKey();\n        const index = groupBy.indexOf(primaryKey);\n        groupBy.splice(index, 1);\n        query.groupBy = groupBy.length > 0 ? groupBy : null;\n    }\n    if (query.groupBy) {\n        if (query.aggregate) {\n            this.executeAggregateGroupBy();\n        }\n        else {\n            this.processGroupBy();\n        }\n    }\n    else if (query.aggregate) {\n        this.processAggregateQry();\n    }\n};\n\nconst getOrderColumnInfo = function (this: Select, orderColumn: string) {\n    let column: IColumn;\n    if (!this.query.store) {\n        if (this.query.join == null) {\n            column = this.getColumnInfo(orderColumn);\n        }\n        else {\n            const splittedByDot = removeSpace(orderColumn).split(\".\");\n            const joinOrderColumn = splittedByDot[1];\n            if (process.env.NODE_ENV !== 'production' && joinOrderColumn == null) {\n                new LogHelper(ERROR_TYPE.ColumnNotExist,\n                    { column: orderColumn, isOrder: true, isJoin: true }\n                ).throw()\n            }\n            column = this.getColumnInfo(joinOrderColumn, splittedByDot[0]);\n        }\n    }\n    if (column == null) {\n        const valueFromFirstColumn = this.results[0][orderColumn];\n        if (valueFromFirstColumn) {\n            return {\n                dataType: getDataType(valueFromFirstColumn),\n                name: orderColumn\n            } as IColumn;\n        }\n        throw new LogHelper(ERROR_TYPE.ColumnNotExist,\n            { column: orderColumn, isOrder: true }\n        )\n\n    }\n    return column;\n}\n\nconst compareStringInDesc_ = (a: string, b: string) => {\n    return b.localeCompare(a);\n}\n\nconst compareStringinAsc_ = (a: string, b: string) => {\n    return a.localeCompare(b);\n}\n\nconst compareDefaultInDesc_ = (a: string, b) => {\n    return new String(b).localeCompare(a);\n}\n\nconst compareDefaultinAsc_ = (a, b: string) => {\n    return new String(a).localeCompare(b);\n}\n\nconst compareNumberInDesc_ = (a: number, b: number) => {\n    return b - a;\n}\n\nconst compareNumberinAsc_ = (a: number, b: number) => {\n    return a - b;\n}\n\nconst compareDateInDesc_ = (a: Date, b: Date) => {\n    return b.getTime() - a.getTime();\n}\n\nconst compareDateInAsc_ = (a: Date, b: Date) => {\n    return a.getTime() - b.getTime();\n}\n\nconst getValueComparer_ = (column: IColumn, order: IOrderQuery): (a, b) => number => {\n    switch (column.dataType) {\n        case DATA_TYPE.String:\n            return order.type === 'asc' ? compareStringinAsc_ : compareStringInDesc_;\n        case DATA_TYPE.Number:\n            return order.type === 'asc' ? compareNumberinAsc_ : compareNumberInDesc_;\n        case DATA_TYPE.DateTime:\n            return order.type === 'asc' ? compareDateInAsc_ : compareDateInDesc_;\n        default:\n            return order.type === 'asc' ? compareDefaultinAsc_ : compareDefaultInDesc_;\n    }\n\n}\n\nconst orderBy_ = function (this: Select, order: IOrderQuery) {\n    order.type = getOrderType_(order.type);\n    let orderColumn = order.by;\n    const thenEvaluator = this.thenEvaluator;\n    if (orderColumn != null && typeof orderColumn === DATA_TYPE.Object) {\n        const caseQuery = orderColumn as { [columnName: string]: [ICaseOption] };\n        const getValInAscDesc = (stringComparer, numberComparer) => {\n            return (value1, value2) => {\n                for (const columnName in caseQuery) {\n                    thenEvaluator.setCaseAndValue(caseQuery, value1);\n                    const column1 = thenEvaluator.setColumn(columnName).evaluate();\n                    thenEvaluator.setCaseAndValue(caseQuery, value2);\n                    const column2 = thenEvaluator.setColumn(columnName).evaluate();\n                    switch (typeof value1[column1]) {\n                        case DATA_TYPE.String:\n                            return stringComparer(value1[column1], value2[column2]);\n                        default:\n                            return numberComparer(value1[column1], value2[column2]);\n                    }\n                }\n            }\n        };\n        let sortMethod = order.type === 'asc' ?\n            getValInAscDesc(compareStringinAsc_, compareNumberinAsc_) :\n            getValInAscDesc(compareStringInDesc_, compareNumberInDesc_);\n\n        this.results.sort(sortMethod);\n    }\n    else {\n        const columnInfo = getOrderColumnInfo.call(this, orderColumn as string);\n        if (columnInfo != null) {\n            const orderMethod = getValueComparer_(columnInfo, order);\n            orderColumn = columnInfo.name;\n            if (order.case == null) {\n                this.results.sort((a, b) => {\n                    return orderMethod(a[orderColumn as string], b[orderColumn as string]);\n                });\n            }\n            else {\n                thenEvaluator.setCaseAndColumn({ [orderColumn as string]: order.case }, orderColumn as string);\n                this.results.sort((a, b) => {\n                    return orderMethod(\n                        thenEvaluator.setValue(a).evaluate(),\n                        thenEvaluator.setValue(b).evaluate()\n                    );\n                });\n            }\n        }\n    }\n\n}\n\nconst getOrderType_ = (type: string) => {\n    return type == null ? 'asc' : type.toLowerCase();\n}\n\nexport const processOrderBy = function (this: Select) {\n    const order = this.query.order;\n    if (order && this.results.length > 0 && !this.sorted) {\n        const orderQueryType = getDataType(order);\n        if (orderQueryType === DATA_TYPE.Object) {\n            orderBy_.call(this, order);\n        }\n        else if (orderQueryType === DATA_TYPE.Array) {\n            orderBy_.call(this, order[0]);\n            for (let i = 1, length = (order as any).length; i < length; i++) {\n                const prevOrderQueryBy = order[i - 1].by;\n                const currentOrderQuery: IOrderQuery = order[i];\n                let currentorderQueryBy = currentOrderQuery.by;\n                const orderColumnDetail = getOrderColumnInfo.call(this, currentorderQueryBy as string);\n                if (orderColumnDetail != null) {\n                    currentorderQueryBy = orderColumnDetail.name;\n                    currentOrderQuery.type = getOrderType_(currentOrderQuery.type);\n                    const orderMethod = getValueComparer_(orderColumnDetail, currentOrderQuery);\n                    this.results.sort((a, b) => {\n                        if (a[prevOrderQueryBy] === b[prevOrderQueryBy]) {\n                            return orderMethod(\n                                a[currentorderQueryBy as string],\n                                b[currentorderQueryBy as string]\n                            );\n                        }\n                        return 0;\n                    });\n                }\n            }\n        }\n    }\n}\n\nexport const processAggregateQry = function (this: Select) {\n    const datas = this.results;\n    const datasLength = datas.length;\n    const results = {};\n    let columnToAggregate;\n\n    const getCount = () => {\n        let result = 0;\n        for (const i in datas) {\n            result += datas[i][columnToAggregate] ? 1 : 0;\n        }\n        return result;\n    };\n    const getMax = () => {\n        let result = 0;\n        for (const i in datas) {\n            result = result > datas[i][columnToAggregate] ?\n                result : datas[i][columnToAggregate];\n        }\n        return result;\n    };\n    const getMin = () => {\n        let result = Infinity, value = Infinity;\n        for (const i in datas) {\n            value = datas[i][columnToAggregate] ?\n                datas[i][columnToAggregate] : Infinity;\n            result = result < value ? result : value;\n        }\n        return result;\n    };\n    const getSum = () => {\n        let result = 0;\n        for (const i in datas) {\n            result += datas[i][columnToAggregate];\n        }\n        return result;\n    };\n    const getAvg = () => {\n        return getSum() / datasLength;\n    };\n    const aggregateQry = this.query.aggregate;\n    for (const prop in aggregateQry) {\n        const aggregateColumn = aggregateQry[prop];\n        const aggregateValType = getDataType(aggregateColumn);\n        let aggregateCalculator;\n        switch (prop) {\n            case 'count':\n                aggregateCalculator = getCount; break;\n            case 'max':\n                aggregateCalculator = getMax; break;\n            case 'min':\n                aggregateCalculator = getMin; break;\n            case 'sum':\n                aggregateCalculator = getSum; break;\n            case 'avg':\n                aggregateCalculator = getAvg;\n        }\n        switch (aggregateValType) {\n            case DATA_TYPE.String:\n                columnToAggregate = aggregateColumn;\n                results[`${prop}(${columnToAggregate})`] = aggregateCalculator();\n                break;\n            case DATA_TYPE.Array:\n                for (const key in aggregateColumn) {\n                    columnToAggregate = aggregateColumn[key];\n                    results[`${prop}(${columnToAggregate})`] = aggregateCalculator();\n                }\n        }\n    }\n\n    // add results to the first index of result\n    for (const prop in results) {\n        datas[0][prop] = results[prop];\n    }\n    this.results = [datas[0]];\n}","export const getObjectFirstKey = (value) => {\n    for (const key in value) {\n        return key;\n    }\n};","import { OCCURENCE } from \"@/common\";\n\nexport const getRegexFromLikeExpression = (likeExpression: string) => {\n    const filterValues = likeExpression.split('%');\n    let filterValue: string;\n    let occurence: OCCURENCE;\n    if (filterValues[1]) {\n        filterValue = filterValues[1];\n        occurence = filterValues.length > 2 ? OCCURENCE.Any : OCCURENCE.Last;\n    }\n    else {\n        filterValue = filterValues[0];\n        occurence = OCCURENCE.First;\n    }\n    switch (occurence) {\n        case OCCURENCE.First:\n            return new RegExp(`^${filterValue}`, 'i');\n        case OCCURENCE.Last:\n            return new RegExp(`${filterValue}$`, 'i');\n        default:\n            return new RegExp(`${filterValue}`, 'i');\n    }\n}","import { getDataType } from \"./get_data_type\";\n\nconst isObject = (value) => {\n    return getDataType(value) === 'object' && !(value instanceof RegExp);\n};\n\nexport const clone = (obj) => {\n    if (isObject(obj)) {\n        const copy = {};\n        for (const i in obj) {\n            copy[i] = obj[i] != null && isObject(obj[i]) ? clone(obj[i]) : obj[i];\n        }\n        return copy;\n    }\n    return obj;\n};","import { getDataType } from \"./get_data_type\"\nimport { QUERY_OPTION, DATA_TYPE } from \"@/common\";\nimport { isArray } from \"./is_array\";\n\nexport const compare = (value, compareValue, symbol?) => {\n    const type1 = getDataType(value);\n    const type2 = getDataType(compareValue);\n\n    if (type1 !== type2) return false;\n    if (type1 === DATA_TYPE.DateTime) {\n        value = value.getTime();\n        compareValue = compareValue.getTime();\n    }\n    switch (symbol) {\n        // greater than\n        case QUERY_OPTION.GreaterThan:\n            return value > compareValue;\n        // less than\n        case QUERY_OPTION.LessThan:\n            return value < compareValue;\n        // less than equal\n        case QUERY_OPTION.LessThanEqualTo:\n            return value <= compareValue;\n        // greather than equal\n        case QUERY_OPTION.GreaterThanEqualTo:\n            return value >= compareValue;\n        // Not equal to\n        case QUERY_OPTION.NotEqualTo:\n            return value !== compareValue;\n        default:\n            if (type1 === 'array') {\n                if (value.length !== compareValue.length) return false;\n                let status;\n                value.every((item, index) => {\n                    status = item === compareValue[index];\n                    return status;\n                });\n                return status;\n            }\n            return value === compareValue;\n    }\n}","import { QUERY_OPTION } from \"@/common\";\nimport { getDataType, clone, compare, getRegexFromLikeExpression, isArray } from \"@worker/utils\";\n\n/**\n * For matching the different column value existance for where option\n * \n * @export\n * @class WhereChecker\n */\nexport class WhereChecker {\n  where: object;\n  checkFlag: boolean;\n\n  constructor(where: object, checkFlag: boolean) {\n    this.where = clone(where);\n    this.checkFlag = checkFlag;\n  }\n\n  remove(props: string[]) {\n    const last = props.pop();\n    const value = props.reduce((prev, curr) => prev && prev[curr], this.where);\n    delete value[last];\n  }\n\n  check(rowValue) {\n    let status = true;\n    if (!this.checkFlag) return status;\n    const where = this.where;\n    for (let columnName in where) {\n      if (!status) {\n        return status;\n      }\n      const whereColumnValue = where[columnName];\n      const columnValue = rowValue[columnName];\n      const isArrayColumnValue = isArray(columnValue);\n      const isArrayWhereColumnValue = isArray(whereColumnValue);\n      const executeCompare = (executor: Function) => {\n        if (isArrayColumnValue && !isArrayWhereColumnValue) {\n          columnValue.every(q => {\n            status = executor(q);\n            return !status;\n          })\n        }\n        else {\n          status = executor(columnValue);\n        }\n        return\n      }\n\n      if (getDataType(whereColumnValue) === \"object\") {\n        for (const key in whereColumnValue) {\n          if (!status) {\n            return status;\n          }\n          switch (key) {\n            case QUERY_OPTION.In:\n              executeCompare((compareValue) => {\n                return this.checkIn(whereColumnValue[QUERY_OPTION.In], compareValue);\n              })\n              break;\n            case QUERY_OPTION.Like:\n              executeCompare((compareValue) => {\n                return this.checkLike_(columnName, compareValue);\n              })\n              break;\n            case QUERY_OPTION.Regex:\n              executeCompare((compareValue) => {\n                return this.checkRegex(columnName, compareValue);\n              })\n              break;\n            case QUERY_OPTION.Between:\n            case QUERY_OPTION.GreaterThan:\n            case QUERY_OPTION.LessThan:\n            case QUERY_OPTION.GreaterThanEqualTo:\n            case QUERY_OPTION.LessThanEqualTo:\n            case QUERY_OPTION.NotEqualTo:\n              executeCompare((compareValue) => {\n                return this.checkComparisionOp_(columnName, compareValue, key);\n              })\n              break;\n            default:\n              status = false;\n          }\n        }\n      }\n      else {\n        executeCompare((storedValue) => {\n          return compare(whereColumnValue, storedValue);\n        });\n      }\n    }\n    return status;\n  }\n\n  private checkIn(whereColumnValue: any[], value) {\n    return whereColumnValue.find(q => compare(q, value)) != null;\n  }\n\n  private checkLike_(column, value) {\n    return getRegexFromLikeExpression(this.where[column][QUERY_OPTION.Like]).test(value);\n  }\n\n  private checkRegex(column, value) {\n    return this.where[column][QUERY_OPTION.Regex].test(value);\n  }\n\n  private checkComparisionOp_(column, value, symbol) {\n    const compareValue = this.where[column][symbol];\n    if (symbol != QUERY_OPTION.Between) {\n      return compare(value, compareValue, symbol);\n    }\n    return compare(value, compareValue.low, '>=') &&\n      compare(value, compareValue.high, '<=');\n  }\n}","import { Base } from \"./base\";\nimport { ISelectQuery, QUERY_OPTION, ERROR_TYPE } from \"@/common\";\nimport { getRegexFromLikeExpression, promiseReject } from \"@worker/utils\";\nimport { LogHelper, getObjectFirstKey, getDataType, getLength } from \"@worker/utils\";\nimport { WhereChecker } from \"./where_checker\";\nimport { executeWhereLogic } from \"./select/where\";\nimport { executeInLogic } from \"./select/in\";\nimport { executeRegexLogic } from \"./select/regex\";\n\nexport class BaseFetch extends Base {\n    query: ISelectQuery;\n    whereChecker: WhereChecker;\n    executeWhereLogic: typeof executeWhereLogic;\n    skipRecord;\n    limitRecord;\n    limitAtEnd = false;\n    skipAtEnd = false;\n    executeInLogic: typeof executeInLogic;\n    executeRegexLogic: typeof executeRegexLogic;\n\n    resultCount: number;\n\n    protected shouldAddValue: (value) => boolean;\n    protected goToWhereLogic() {\n        const query = this.query as ISelectQuery;\n        const whereQuery = query.where;\n        let firstColumn = (() => {\n            for (const key in whereQuery) {\n                if (this.objectStore.indexNames.contains(key)) {\n                    return key;\n                }\n            }\n        })();\n        if (firstColumn == null) {\n            firstColumn = getObjectFirstKey(whereQuery);\n            if (!query.store) {\n                return promiseReject(\n                    new LogHelper(ERROR_TYPE.NoIndexFound, { column: firstColumn })\n                );\n            }\n        }\n        const value = whereQuery[firstColumn];\n        if (getDataType(value) === 'object') {\n            const checkFlag = getLength(value) > 1 ||\n                getLength(whereQuery) > 1\n\n            this.whereChecker = new WhereChecker(whereQuery, checkFlag);\n            const key = getObjectFirstKey(value);\n            this.whereChecker.remove([firstColumn, key]);\n            switch (key) {\n                case QUERY_OPTION.Like: {\n                    const regexVal = getRegexFromLikeExpression(value[QUERY_OPTION.Like]);\n                    return this.executeRegexLogic(firstColumn, regexVal);\n                }\n                case QUERY_OPTION.Regex:\n                    return this.executeRegexLogic(firstColumn, value[QUERY_OPTION.Regex]);\n                case QUERY_OPTION.In:\n                    return this.executeInLogic(\n                        firstColumn, value[QUERY_OPTION.In]\n                    );\n                case QUERY_OPTION.Between:\n                case QUERY_OPTION.GreaterThan:\n                case QUERY_OPTION.LessThan:\n                case QUERY_OPTION.GreaterThanEqualTo:\n                case QUERY_OPTION.LessThanEqualTo:\n                    return this.executeWhereLogic(firstColumn, value, key, \"next\");\n                case QUERY_OPTION.Aggregate: break;\n                default:\n                    return this.executeWhereLogic(firstColumn, value, null, \"next\");\n            }\n        }\n        else {\n            const checkFlag = getLength(whereQuery) > 1;\n            this.whereChecker = new WhereChecker(whereQuery, checkFlag);\n            this.whereChecker.remove([firstColumn]);\n            return this.executeWhereLogic(firstColumn, value, null, \"next\");\n        }\n    }\n\n}","import { BaseFetch } from \"../base_fetch\";\nimport { Select } from \".\";\nimport { promise } from \"@/common\";\nimport { executeLimitForWhere_, executeSimpleForWhere_, getCursorOnSuccess } from \"./where\";\n\n\nexport const executeRegexLogic = function (this: BaseFetch, column, exp: RegExp) {\n\n    let skip = this.skipRecord;\n    const skipOrPush = (val) => {\n        if (skip === 0) {\n            (this as Select)['pushResult'](val);\n        }\n        else {\n            --skip;\n        }\n    };\n    this.shouldAddValue = (cursor) => {\n        return exp.test(cursor.key) &&\n            this.whereChecker.check(cursor.value);\n    };\n\n    const cursorRequest = this.objectStore.index(column).openCursor();\n\n    const onSuccess = getCursorOnSuccess.call(\n        this,\n        executeSimpleForWhere_,\n        executeLimitForWhere_,\n        executeSkipForWhere_,\n        executeSkipAndLimitForWhere_\n    );\n\n    return promise<any>((res, rej) => {\n        cursorRequest.onerror = rej;\n        cursorRequest.onsuccess = onSuccess.call(this, res, skipOrPush);\n    })\n\n}\n\nexport const executeSkipAndLimitForWhere_ = function (this: Select, onFinish, skipOrPush) {\n    return (e: any) => {\n        const cursor = e.target.result;\n        if (this.results.length !== this.limitRecord && cursor) {\n            if (this.shouldAddValue(cursor)) {\n                skipOrPush(cursor.value);\n            }\n            cursor.continue();\n        } else {\n            onFinish();\n        }\n    };\n}\n\nexport const executeSkipForWhere_ = function (this: Select, onFinish, skipOrPush) {\n    return (e: any) => {\n        const cursor = e.target.result;\n        if (cursor) {\n            if (this.shouldAddValue(cursor)) {\n                skipOrPush((cursor.value));\n            }\n            cursor.continue();\n        } else {\n            onFinish();\n        }\n    };\n}\n\n\n\n\n","import { Select } from \"./\";\nimport { IJoinQuery, DATA_TYPE, ERROR_TYPE, ISelectQuery } from \"@/common\";\nimport { getDataType, LogHelper, removeSpace, promiseReject, getKeys, getLength } from \"@/worker/utils\";\nimport { WhereChecker } from \"@executors/where_checker\";\n\n\nexport const executeJoinQuery = function (this: Select) {\n    return new Join(this).execute();\n}\n\ninterface JoinQueryWithInfo extends IJoinQuery {\n    joinTableInfo: JoinTableInfo\n}\n\nclass Join {\n\n    private joinQueryStack_: JoinQueryWithInfo[] = [];\n    private currentQueryStackIndex_ = 0;\n    tablesFetched = [];\n    results = [];\n\n    select: Select;\n    constructor(select: Select) {\n        this.select = select;\n    }\n\n    get query() {\n        return this.select.query;\n    }\n\n    getTable(name: string) {\n        return this.select.table(name);\n    }\n\n    private executeSelect(query: ISelectQuery) {\n        return new Select(query, this.select.util).\n            execute();\n    }\n\n    execute() {\n        const query = this.query;\n        this.joinQueryStack_ = getDataType(query.join) === DATA_TYPE.Object ?\n            [query.join as JoinQueryWithInfo] : query.join as JoinQueryWithInfo[];\n        // get the data for first table\n        const tableName = query.from;\n        const tablesToFetch = [];\n        if (tableName) {\n            tablesToFetch.push(tableName);\n        }\n        const joinQueryStack = this.joinQueryStack_;\n        for (let i = 0, length = joinQueryStack.length; i < length; i++) {\n            const item = joinQueryStack[i];\n            let jointblInfo = this.getJoinTableInfo_(item.on);\n            // table 1 is fetched & table2 needs to be fetched for join\n            if (item.with === jointblInfo.table1.table) {\n                jointblInfo = {\n                    table1: jointblInfo.table2,\n                    table2: jointblInfo.table1\n                };\n            }\n\n            const err = this.checkJoinQuery_(jointblInfo, item);\n            if (err) {\n                return promiseReject(err);\n            }\n            joinQueryStack[i].joinTableInfo = jointblInfo;\n            if (item.with) {\n                tablesToFetch.push(item.with)\n            }\n        }\n\n        if (!this.select.isTxQuery && tablesToFetch.length > 0) {\n            this.select.util.createTransaction(tablesToFetch);\n        }\n\n        const whereQuery = query.where;\n        // remove column which not exist in first table\n        if (whereQuery && !query.store) {\n            const table = this.getTable(tableName);\n            const removeJoinColumn = (whereQryParam) => {\n                let whereQryAfterJoin;\n                if (Array.isArray(whereQryParam)) {\n                    whereQryAfterJoin = [];\n                    whereQryParam = whereQryParam.filter((qry) => {\n                        const result = removeJoinColumn(qry);\n                        if (Object.keys(result.whereQryAfterJoin).length > 0) {\n                            whereQryAfterJoin.push(result.whereQryAfterJoin);\n                        }\n                        return !result.isWhereEmpty\n                    });\n                }\n                else {\n                    whereQryAfterJoin = {};\n                    for (const column in whereQryParam) {\n                        switch (column) {\n                            case \"or\":\n                                const filteredOr = {};\n                                const whereQryOr = whereQryParam[column];\n                                for (const orColumn in whereQryOr) {\n                                    const columnInTable = table.columns.find(q => q.name === orColumn);\n                                    if (!columnInTable) {\n                                        filteredOr[orColumn] = whereQryOr[orColumn];\n                                    }\n                                }\n                                if (getLength(filteredOr) > 0) {\n                                    whereQryAfterJoin['or'] = filteredOr;\n                                    for (const orColumn in filteredOr) {\n                                        delete whereQryOr[orColumn];\n                                    }\n                                }\n                                break;\n                            default:\n                                const columnInTable = table.columns.find(q => q.name === column);\n                                if (!columnInTable) {\n                                    whereQryAfterJoin[column] = whereQuery[column];\n                                }\n                        }\n                    }\n                    for (const column in whereQryAfterJoin) {\n                        delete whereQryParam[column];\n                    }\n                }\n                return {\n                    isWhereEmpty: getLength(whereQryParam) === 0,\n                    whereQryAfterJoin,\n                    whereQueryModified: whereQryParam\n                }\n            }\n            const removeJoinColumnResult = removeJoinColumn(whereQuery);\n            const whereQryAfterJoin = removeJoinColumnResult.whereQryAfterJoin;\n            query.where = removeJoinColumnResult.whereQueryModified;\n            if (removeJoinColumnResult.isWhereEmpty) {\n                delete query.where;\n            }\n            const joinQuery = this.joinQueryStack_[0];\n            Object.assign(joinQuery['whereJoin'], whereQryAfterJoin);\n        }\n\n        return this.executeSelect({\n            from: tableName,\n            where: query.where,\n            case: query.case,\n            flatten: query.flatten,\n            store: query.store,\n            meta: query.meta\n        }).then(results => {\n            this.results = results.map((item) => {\n                return {\n                    [this.currentQueryStackIndex_]: item\n                };\n            });\n            this.tablesFetched.push(\n                joinQueryStack[0].joinTableInfo.table1.table\n            );\n            return this.startExecutingJoinLogic_();\n        });\n    }\n\n    private onJoinQueryFinished_() {\n        if (this.results.length === 0) return;\n        const selectApi = this.select;\n        try {\n            let results = [];\n            const tables = getKeys(this.results[0]);\n            const tablesLength = tables.length;\n            this.results.forEach((result) => {\n                let data = result[\"0\"]; // first table data\n                for (let i = 1; i < tablesLength; i++) {\n                    data = { ...data, ...result[i] };\n                }\n                results.push(data);\n            });\n            selectApi['results'] = results;\n            selectApi.setLimitAndSkipEvaluationAtEnd_();\n            selectApi.query.flatten = null;\n            if (process.env.NODE_ENV !== 'production') {\n                try {\n                    selectApi.processOrderBy();\n                }\n                catch (ex) {\n                    return promiseReject(\n                        new LogHelper(ERROR_TYPE.InvalidOrderQuery, ex.message)\n                    );\n                }\n            }\n            else {\n                selectApi.processOrderBy();\n            }\n        }\n        catch (ex) {\n            console.error(ex);\n            return promiseReject(\n                new LogHelper(ERROR_TYPE.InvalidJoinQuery, ex.message)\n            );\n        }\n    }\n\n    private startExecutingJoinLogic_() {\n        const joinQuery = this.joinQueryStack_[this.currentQueryStackIndex_];\n        if (joinQuery) {\n            try {\n                let jointblInfo = joinQuery.joinTableInfo;\n                return this.executeSelect({\n                    from: joinQuery.with,\n                    where: joinQuery.where,\n                    case: joinQuery.case,\n                    flatten: joinQuery.flatten,\n                    store: joinQuery.store,\n                    meta: joinQuery.meta\n                }).then(results => {\n                    this.jointables(joinQuery, jointblInfo, results);\n                    this.tablesFetched.push(jointblInfo.table2.table);\n                    ++this.currentQueryStackIndex_;\n                    return this.startExecutingJoinLogic_();\n                });\n            }\n            catch (ex) {\n                console.error(ex);\n                return promiseReject(\n                    new LogHelper(ERROR_TYPE.InvalidJoinQuery, ex.message)\n                );\n            }\n        }\n        else {\n            return this.onJoinQueryFinished_();\n        }\n    }\n\n    private jointables(joinQuery: JoinQueryWithInfo, jointblInfo: JoinTableInfo, secondtableData: any[]) {\n        const joinType = joinQuery.type;\n        const output = [];\n        const column1 = jointblInfo.table1.column;\n        const column2 = jointblInfo.table2.column;\n        const table1Index = this.tablesFetched.indexOf(jointblInfo.table1.table);\n        const table2Index = this.currentQueryStackIndex_ + 1;\n        const asQuery = joinQuery.as;\n        const mapWithAlias = asQuery ? (value: object) => {\n            for (const key in asQuery) {\n                const asValue = asQuery[key];\n                if (value[asValue] === undefined) {\n                    value[asValue] = value[key];\n                    delete value[key];\n                }\n            }\n            return value;\n        } : (val) => val;\n\n        let index = 0;\n        let valueMatchedFromSecondTable: any[];\n        const whereQry = Object.assign({}, joinQuery['whereJoin']);\n        const whereCheker = new WhereChecker(whereQry, (getLength(whereQry) > 0));\n        let joinerComparer: (valueFromSecondTable, valueFromFirstTable) => boolean;\n\n        const performInnerJoin = () => {\n            joinerComparer = (valueFromSecondTable, valueFromFirstTable,) => {\n                return valueFromFirstTable[table1Index][column1] === valueFromSecondTable[column2];\n            }\n            defaultValueSetter = () => { };\n        };\n\n        let defaultValueSetter;\n        const performleftJoin = () => {\n            const columnDefaultValue = {};\n            const nullValue = null;\n            if (joinQuery.store) {\n                getKeys(joinQuery.store).forEach(columnName => {\n                    columnDefaultValue[columnName] = nullValue;\n                })\n            }\n            else {\n                this.getTable(jointblInfo.table2.table).columns.forEach(col => {\n                    columnDefaultValue[col.name] = nullValue;\n                });\n            }\n\n            if (table2Index === 1) {\n                joinerComparer = function (valueFromSecondTable, valueFromFirstTable) {\n                    return valueFromFirstTable[table1Index][column1] === valueFromSecondTable[column2];\n                };\n            }\n            else {\n                joinerComparer = function (valueFromSecondTable, valueFromFirstTable) {\n                    const value = valueFromFirstTable[table1Index];\n                    return value != null && value[column1] === valueFromSecondTable[column2];\n                };\n            }\n\n            defaultValueSetter = () => {\n                if (valueMatchedFromSecondTable.length === 0) {\n                    valueMatchedFromSecondTable = [columnDefaultValue];\n                }\n            }\n        };\n        switch (joinType) {\n            case \"left\":\n                performleftJoin(); break;\n            default:\n                performInnerJoin();\n        }\n        this.results.forEach((valueFromFirstTable) => {\n            valueMatchedFromSecondTable = [];\n            // perform left join\n            secondtableData.forEach(valueFromSecondTable => {\n                if (joinerComparer(valueFromSecondTable, valueFromFirstTable)) {\n                    valueMatchedFromSecondTable.push({\n                        ...valueFromSecondTable\n                    });\n                }\n            });\n\n            defaultValueSetter();\n\n            valueMatchedFromSecondTable.forEach(function (value) {\n                value = mapWithAlias(value);\n                if (!whereCheker.check(value)) return;\n\n                output[index] = { ...valueFromFirstTable };\n                output[index++][table2Index] = value;\n            });\n        });\n        this.results = output;\n    }\n\n    private getJoinTableInfo_(joinOn: string) {\n        joinOn = removeSpace(joinOn);\n        const splittedjoinOn = joinOn.split(\"=\");\n        if (process.env.NODE_ENV !== 'production') {\n            if (splittedjoinOn.length !== 2) {\n                throw new LogHelper(ERROR_TYPE.InvalidJoinQuery,\n                    `The 'on' clause ('${joinOn}') is missing an '=' operator. Ensure the condition properly relates columns from both tables.`\n                );\n            }\n        }\n        const splittedjoinOnbydotFirst = splittedjoinOn[0].split(\".\");\n        const splittedjoinOnbydotSecond = splittedjoinOn[1].split(\".\");\n        const info = {\n            table1: {\n                table: splittedjoinOnbydotFirst[0],\n                column: splittedjoinOnbydotFirst[1]\n            },\n            table2: {\n                table: splittedjoinOnbydotSecond[0],\n                column: splittedjoinOnbydotSecond[1]\n            }\n        } as JoinTableInfo;\n        return info;\n    }\n\n    private checkJoinQuery_(jointblInfo: JoinTableInfo, qry: IJoinQuery) {\n        if (qry.store) return null;\n\n        const table1 = jointblInfo.table1;\n        const table2 = jointblInfo.table2;\n        const tableSchemaOf1stTable = this.getTable(table1.table);\n        const tableSchemaOf2ndTable = this.getTable(table2.table);\n\n        if (process.env.NODE_ENV !== 'production') {\n            if (tableSchemaOf1stTable == null || tableSchemaOf2ndTable == null) {\n                return new LogHelper(ERROR_TYPE.InvalidJoinQuery,\n                    `The 'on' condition references tables or columns ('${table1.table}.${table1.column}', '${table2.table}.${table2.column}') that do not exist or are not part of the join. Ensure that the tables and columns used in the 'on' condition match those specified in the 'from' and 'with' clauses.`\n                );\n            }\n        }\n\n        let err: LogHelper;\n        // check on info & with info \n        if (qry.with !== table2.table) {\n            err = new LogHelper(ERROR_TYPE.InvalidJoinQuery,\n                `The 'on' condition must reference a column from the table specified in 'with'. Found '${qry.on}', but '${qry.with}' was provided in 'with'.`\n            );\n        }\n\n        // check for column existance\n        if (tableSchemaOf1stTable.columns.find(q => q.name === table1.column) == null) {\n            err = new LogHelper(ERROR_TYPE.InvalidJoinQuery,\n                `column ${table1.column} does not exist in table ${table1.table}`\n            );\n        }\n        else if (tableSchemaOf2ndTable.columns.find(q => q.name === table2.column) == null) {\n            err = new LogHelper(ERROR_TYPE.InvalidJoinQuery,\n                `column ${table2.column} does not exist in table ${table2.table}`\n            );\n        }\n\n        // check for column match in both table\n        if (qry.as == null) {\n            qry.as = {};\n        }\n        tableSchemaOf1stTable.columns.every(function (column) {\n            const columnFound = tableSchemaOf2ndTable.columns.find(q => q.name === column.name && q.name !== table1.column);\n            if (columnFound != null && qry.as[columnFound.name] == null) {\n                err = new LogHelper(ERROR_TYPE.InvalidJoinQuery,\n                    `column ${column.name} exist in both table ${table1.table} & ${table2.table}`\n                );\n                return false;\n            }\n            return true;\n        });\n        let whereQry = qry.where;\n        if (whereQry) {\n            const removeNonExistingColumnFromCurrentTable = (qry, whereJoinParam) => {\n                for (const columnName in qry) {\n                    switch (columnName) {\n                        case \"or\":\n                        case \"in\":\n                            break;\n                        default:\n                            const columnFound = tableSchemaOf2ndTable.columns.find(q => q.name === columnName);\n                            if (!columnFound) {\n                                whereJoinParam[columnName] = qry[columnName];\n                                delete qry[columnName];\n                            }\n                    }\n                }\n            }\n            let whereJoin;\n            if (Array.isArray(whereQry)) {\n                whereJoin = [];\n                whereQry = whereQry.filter(item => {\n                    const whereForExtraColumn = {};\n                    removeNonExistingColumnFromCurrentTable(item, whereForExtraColumn);\n                    if (getLength(whereForExtraColumn) !== 0) {\n                        whereJoin.push(whereForExtraColumn);\n                    }\n                    return getLength(item) !== 0\n                });\n            }\n            else {\n                whereJoin = {};\n                removeNonExistingColumnFromCurrentTable(whereQry, whereJoin);\n            }\n            if (getLength(whereQry) === 0) {\n                qry.where = null;\n            }\n            qry['whereJoin'] = whereJoin;\n        }\n        else {\n            qry['whereJoin'] = {};\n        }\n        return err;\n    }\n}\n\ntype JoinTableInfo = {\n    table1: { table: string, column: string }\n    table2: { table: string, column: string }\n};\n","import { promiseResolve } from \"@/common\";\nimport { getKeys } from \"../utils\";\n\nexport class MemoryObjectStore {\n    data: any[];\n\n    constructor(data: any[]) {\n        this.data = data;\n    }\n\n    get indexNames() {\n        const keys = getKeys(this.data[0])\n        return {\n            contains(columnName: string) {\n                return keys.indexOf(columnName) >= 0;\n            }\n        }\n    }\n\n    index(column: string) {\n        return {\n            openCursor: (keyRange?: IDBKeyRange) => {\n                const cursorRequest = {\n\n                } as {\n                    onsuccess: Function,\n                    onerror: Function\n                }\n                let index = 0;\n                const cursor = {\n                    continue() {\n                        ++index;\n                        execute();\n                    },\n                }\n                const callOnSuccess = (result) => {\n                    cursorRequest.onsuccess({\n                        target: {\n                            result\n                        }\n                    });\n                }\n                const execute = () => {\n                    const value = this.data[index];\n                    if (value) {\n                        const columnValue = value[column];\n                        if (columnValue && (keyRange == null || keyRange.includes(columnValue))) {\n                            (cursor as any).key = columnValue;\n                            (cursor as any).value = value;\n                            callOnSuccess(cursor)\n                        }\n                        else {\n                            cursor.continue();\n                        }\n                    }\n                    else {\n                        callOnSuccess(null);\n                    }\n                }\n                promiseResolve().then(execute);\n                return cursorRequest;\n            }\n        }\n    }\n}","import { ISelectQuery, QUERY_OPTION, IDB_MODE, API, IWhereQuery, promiseResolve, IOrderQuery } from \"@/common\";\nimport { IDBUtil } from \"@/worker/idbutil\";\nimport { QueryHelper } from \"@worker/executors/query_helper\";\nimport { isArray, isObject, getObjectFirstKey, promiseReject, getLength } from \"@/worker/utils\";\nimport { setPushResult, setLimitAndSkipEvaluationAtEnd, mergeWithResults } from \"./base_select\";\nimport { ThenEvaluator } from \"./then_evaluator\";\nimport { executeWhereUndefinedLogic } from \"./not_where\"\nimport { processAggregateQry, processGroupDistinctAggr, processOrderBy } from \"./order_by\";\nimport { executeAggregateGroupBy, processGroupBy } from \"./group_by\";\nimport { executeWhereLogic } from \"./where\";\nimport { BaseFetch } from \"@executors/base_fetch\";\nimport { executeInLogic } from \"./in\";\nimport { executeRegexLogic } from \"./regex\";\nimport { executeJoinQuery } from \"./join\";\nimport { MemoryObjectStore } from \"@/worker/memory_store\";\n\nexport class Select extends BaseFetch {\n    sorted = false;\n    isOr: boolean;\n    isArrayQry: boolean;\n    query: ISelectQuery;\n    orInfo: {\n        results?: any[];\n        orQuery: object\n    };\n\n    isSubQuery = false;\n\n    protected pushResult: (value) => void;\n\n    protected thenEvaluator = new ThenEvaluator();\n\n    executeWhereUndefinedLogic: typeof executeWhereUndefinedLogic;\n\n    setLimitAndSkipEvaluationAtEnd_: typeof setLimitAndSkipEvaluationAtEnd\n    setPushResult: typeof setPushResult;\n    mergeWithResults: typeof mergeWithResults;\n    executeJoinQuery: typeof executeJoinQuery\n    processGroupDistinctAggr: typeof processGroupDistinctAggr;\n    processOrderBy: typeof processOrderBy;\n    processAggregateQry: typeof processAggregateQry;\n    executeAggregateGroupBy: typeof executeAggregateGroupBy;\n    processGroupBy: typeof processGroupBy;\n\n\n    constructor(query: ISelectQuery, util: IDBUtil) {\n        super();\n        this.query = query;\n        this.util = util;\n        this.tableName = query.from;\n        this.setPushResult();\n        if (isArray(query.where)) {\n            this.isArrayQry = true;\n            this.setLimitAndSkipEvaluationAtEnd_();\n        }\n        else {\n            this.skipRecord = query.skip;\n            this.limitRecord = query.limit;\n        }\n        const orderQuery = query.order;\n        if (orderQuery) {\n            if (isArray(orderQuery) || (orderQuery as IOrderQuery).case || isObject((orderQuery as IOrderQuery).by)) {\n                ((orderQuery as IOrderQuery).idbSorting) = false;\n            }\n            this.setLimitAndSkipEvaluationAtEnd_();\n        }\n        else if (query.groupBy) {\n            this.setLimitAndSkipEvaluationAtEnd_();\n        }\n    }\n\n    execute(beforeExecute?: () => Promise<any>): Promise<any> {\n        let pResult: Promise<void>;\n        if (!beforeExecute) {\n            beforeExecute = () => promiseResolve(null);\n        }\n        const query = this.query;\n        try {\n            const err = new QueryHelper(this.db).validate(API.Select, query);\n            if (err) return promiseReject(err);\n            return beforeExecute().then(_ => {\n                this.initTransaction_();\n                if (query.join == null) {\n                    if (query.where != null) {\n                        if (isArray(query.where)) {\n                            pResult = this.processWhereArrayQry();\n                        }\n                        else {\n                            pResult = this.processWhere_();\n                        }\n                    }\n                    else {\n                        pResult = this.executeWhereUndefinedLogic();\n                    }\n                }\n                else {\n                    pResult = this.executeJoinQuery();\n                }\n                return pResult.then(\n                    this.returnResult_.bind(this)\n                )\n            })\n        }\n        catch (ex) {\n            return this.onException(ex);\n        }\n    }\n\n    private processWhereArrayQry() {\n        this.isArrayQry = true;\n        const whereQuery = this.query.where as IWhereQuery[];\n        const pKey = this.primaryKey();\n        let isFirstWhere = true, output = [], operation;\n\n        const isItemExist = (keyValue) => {\n            return output.findIndex(item => item[pKey] === keyValue) >= 0;\n        };\n        const onSuccess = () => {\n            if (operation === QUERY_OPTION.And) {\n                const doAnd = () => {\n                    let andResults = [];\n                    this.results.forEach((item) => {\n                        if (isItemExist(item[pKey])) {\n                            andResults.push(item);\n                        }\n                    });\n                    output = andResults;\n                    andResults = null;\n                };\n\n                if (isFirstWhere === true) {\n                    output = this.results;\n                }\n                else if (output.length > 0) {\n                    doAnd();\n                }\n            }\n            else {\n                if (output.length > 0) {\n                    // this.results = [...output, ...this.results];\n                    this.mergeWithResults(output);\n                }\n                output = this.results;\n            }\n            isFirstWhere = false;\n            if (whereQuery.length > 0) {\n                this.results = [];\n                return processFirstQry();\n            }\n            else {\n                this.results = output;\n            }\n            return promiseResolve();\n        };\n        const executeWhere = (whereQuery): Promise<any> => {\n            const select = new Select({\n                from: this.query.from,\n                where: whereQuery as any\n            }, this.util);\n            return select.execute().then(results => {\n                this.results = results;\n                return onSuccess();\n            });\n        };\n        const processFirstQry = (): Promise<any> => {\n            let whereQueryToProcess = whereQuery.shift();\n            const whereQueryOr = whereQueryToProcess[QUERY_OPTION.Or];\n            if (whereQueryOr) {\n                if (isArray(whereQueryOr)) {\n                    operation = QUERY_OPTION.Or;\n                    return executeWhere(whereQueryOr);\n                }\n                if (getLength(whereQueryToProcess) === 1) {\n                    operation = QUERY_OPTION.Or;\n                    whereQueryToProcess = whereQueryOr as any;\n                }\n                else {\n                    operation = QUERY_OPTION.And;\n                }\n            }\n            else {\n                operation = QUERY_OPTION.And;\n                if (isArray(whereQueryToProcess)) {\n                    return executeWhere(whereQueryToProcess);\n                }\n            }\n            this.query.where = whereQueryToProcess;\n            return this.processWhere_().then(onSuccess);\n        };\n        return processFirstQry();\n    }\n\n    private initTransaction_() {\n        const store = this.query.store\n        if (store) {\n            this.objectStore = new MemoryObjectStore(store as any[]) as any;\n            return\n        }\n        if (!this.isTxQuery) {\n            this.util.createTransactionIfNotExist([this.tableName], IDB_MODE.ReadOnly);\n        }\n        this.objectStore = this.util.objectStore(this.tableName);\n    }\n\n    private processWhere_() {\n        this.shouldAddValue = (cursor: IDBCursorWithValue) => {\n            const cursorValue = cursor.value;\n            const that = this;\n            const proxy = new Proxy(cursorValue, {\n                get(target, p, receiver) {\n                    let val = cursorValue[p];\n                    if (!val) {\n                        const column = that.getColumnInfo(p as string);\n                        if (column && column.keyPath) {\n                            return column.keyPath.map(col => {\n                                return cursorValue[col];\n                            });\n                        }\n                    }\n                    return val;\n                },\n            });\n            return this.whereChecker.check(proxy);\n        };\n        if ((this.query.where as IWhereQuery).or) {\n            this.processOrLogic_();\n        }\n        return this.goToWhereLogic().then(() => {\n            return this.onWhereEvaluated();\n        })\n    }\n\n    private onWhereEvaluated() {\n        if (this.isOr) {\n            return this.orQuerySuccess_();\n        }\n    }\n\n    private returnResult_ = () => {\n        if (this.results.length > 0) {\n            const query = this.query;\n            if (query.flatten) {\n                const flattendData = [];\n                const indexToDelete = new Map<number, Boolean>();\n                query.flatten.forEach(column => {\n                    this.results.forEach((data, i) => {\n                        data[column].forEach(item => {\n                            flattendData.push(\n                                { ...data, ...{ [column]: item } }\n                            );\n                        });\n                        indexToDelete.set(i, true);\n                    });\n                });\n                let itemsDeleted = 0;\n                indexToDelete.forEach((_, key) => {\n                    this.results.splice(key - itemsDeleted, 1);\n                    ++itemsDeleted;\n                });\n                this.results = this.results.concat(flattendData);\n            }\n            this.processGroupDistinctAggr();\n            this.processOrderBy();\n            if (this.skipAtEnd) {\n                this.results.splice(0, query.skip);\n            }\n            if (this.limitAtEnd) {\n                this.results = this.results.slice(0, query.limit);\n            }\n        }\n        return this.results;\n    }\n\n    private orQuerySuccess_() {\n        const query = this.query;\n        const orInfo = this.orInfo;\n        if (this.results.length > 0) {\n            this.mergeWithResults(orInfo.results);\n        }\n        return new Select({\n            where: orInfo.orQuery,\n            from: query.from,\n            case: query.case,\n            store: query.store,\n            meta: query.meta\n        }, this.util).execute().then(results => {\n            this.mergeWithResults(results);\n            this.isOr = false;\n            // free or info memory\n            this.orInfo = null;\n        });\n    }\n\n    private processOrLogic_() {\n        this.isOr = true;\n        const where = this.query.where as IWhereQuery;\n        this.orInfo = {\n            orQuery: where.or as any,\n            results: []\n        };\n        this.setLimitAndSkipEvaluationAtEnd_();\n        // free or memory\n        delete where.or;\n    }\n}\n\nSelect.prototype.executeInLogic = executeInLogic;\nSelect.prototype.executeWhereUndefinedLogic = executeWhereUndefinedLogic;\nSelect.prototype.executeWhereLogic = executeWhereLogic;\nSelect.prototype.executeRegexLogic = executeRegexLogic;\n\nSelect.prototype.setLimitAndSkipEvaluationAtEnd_ = setLimitAndSkipEvaluationAtEnd\nSelect.prototype.setPushResult = setPushResult;\nSelect.prototype.mergeWithResults = mergeWithResults;\nSelect.prototype.executeJoinQuery = executeJoinQuery\nSelect.prototype.processGroupDistinctAggr = processGroupDistinctAggr;\nSelect.prototype.processOrderBy = processOrderBy;\nSelect.prototype.processAggregateQry = processAggregateQry;\nSelect.prototype.executeAggregateGroupBy = executeAggregateGroupBy;\nSelect.prototype.processGroupBy = processGroupBy;\n","export const isObject = (value) => {\n    return typeof value === 'object';\n};","import { getLength, getObjectFirstKey } from \"@/worker/utils\";\n\nexport function isWhereKeysLengthOne(where) {\n    let status = getLength(where) === 1;\n    if (status) {\n        const key = getObjectFirstKey(where);\n        status = getLength(where[key]) === 1;\n    }\n    return status;\n};","import { Select } from \"./\";\nimport { promise, promiseAll } from \"@/common\";\nimport { BaseFetch } from \"../base_fetch\";\nimport { executeLimitForWhere_, executeSimpleForWhere_, getCursorOnSuccess } from \"./where\";\nimport { executeSkipAndLimitForWhere_, executeSkipForWhere_ } from \"./regex\";\n\nexport const executeInLogic = function (this: BaseFetch, column, values) {\n    let skip = this.skipRecord;\n    const skipOrPush = (val) => {\n        if (skip === 0) {\n            (this as Select)['pushResult'](val);\n        }\n        else {\n            --skip;\n        }\n    };\n    const onSuccess = getCursorOnSuccess.call(\n        this,\n        executeSimpleForWhere_,\n        executeLimitForWhere_,\n        executeSkipForWhere_,\n        executeSkipAndLimitForWhere_\n    );\n\n    const runInLogic: (val) => Promise<void> = (value) => {\n        return promise((res, rej) => {\n            const cursorRequest = this.objectStore.index(column).openCursor(\n                this.util.keyRange(value)\n            );\n            cursorRequest.onsuccess = onSuccess.call(this, res, skipOrPush);\n            cursorRequest.onerror = rej;\n        });\n    };\n\n    return promiseAll<void>(\n        values.map(runInLogic)\n    );\n\n};\n","import { LogHelper } from \"@/worker/utils\";\nimport { Select } from \"./index\";\nimport { ERROR_TYPE } from \"@/common\";\n\nexport const setPushResult = function (this: Select) {\n    const caseQuery = this.query.case;\n    if (caseQuery) {\n        this.pushResult = (value) => {\n            let columnName: string;\n            this.thenEvaluator.setCaseAndValue(caseQuery, value);\n            for (columnName in caseQuery) {\n                value[columnName] = this.thenEvaluator.setColumn(columnName).evaluate();\n            }\n            this.results.push(value);\n        };\n    }\n    else {\n        this.pushResult = (value) => {\n            this.results.push(value);\n        };\n    }\n}\n\nexport const setLimitAndSkipEvaluationAtEnd = function (this: Select) {\n    if (this.query.limit) {\n        this.limitAtEnd = true;\n    }\n    if (this.query.skip) {\n        this.skipAtEnd = true;\n    }\n}\n\nexport const mergeWithResults = function (this: Select, from: any[]) {\n    let datas = this.results;\n    const key = this.primaryKey();\n    if (process.env.NODE_ENV !== 'production' && !key) {\n        new LogHelper(ERROR_TYPE.NoPrimaryKey, this.query).warn();\n    }\n    const lookupObject = new Map();\n    datas.forEach(data => {\n        lookupObject.set(data[key], 1);\n    });\n    from.forEach(item => {\n        if (!lookupObject.has(item[key])) {\n            datas.push(item);\n        }\n    });\n}\n","import { Select } from \".\";\nimport { getDataType, getObjectFirstKey } from \"@/worker/utils\";\nimport { QUERY_OPTION, DATA_TYPE } from \"@/common\";\n\nexport const processGroupBy = function (this: Select) {\n    const groupBy = this.query.groupBy as any;\n    let datas = this.results;\n    const lookUpObj = new Map<string, any>();\n\n    const groupByDataType = getDataType(groupBy);\n    if (groupByDataType !== DATA_TYPE.Object) {\n        if (groupByDataType === DATA_TYPE.String) {\n            for (const i in datas) {\n                lookUpObj.set(datas[i][groupBy as string], datas[i]);\n            }\n        }\n        else {\n            let objKey;\n            for (const i in datas) {\n                objKey = \"\";\n                for (const column in groupBy) {\n                    objKey += datas[i][groupBy[column]];\n                }\n                lookUpObj.set(objKey, datas[i]);\n            }\n        }\n    }\n    else {\n        const caseQueryLength = Object.keys(groupBy).length;\n        if (caseQueryLength === 1) {\n            const groupByColumn = getObjectFirstKey(groupBy);\n            this.thenEvaluator.setCaseAndColumn(groupBy, groupByColumn);\n            for (const i in datas) {\n                lookUpObj.set(this.thenEvaluator.setValue(datas[i]).evaluate(), datas[i]);\n            }\n        }\n        else {\n            let objKey;\n            for (const i in datas) {\n                objKey = \"\";\n                this.thenEvaluator.setCaseAndValue(groupBy, datas[i]);\n                for (const column in groupBy) {\n                    objKey += this.thenEvaluator.setColumn(column).evaluate();\n                }\n                lookUpObj.set(objKey, datas[i]);\n            }\n        }\n    }\n\n    this.results = Array.from(lookUpObj.values());\n}\n\nexport const executeAggregateGroupBy = function (this: Select) {\n    const grpQry = this.query.groupBy as any;\n    let datas = this.results;\n\n    const lookUpObj = new Map<string, any>();\n    // assign aggregate\n    const aggregateQry = this.query.aggregate;\n\n    let index;\n    let objKey;\n    let value;\n    let columnToAggregate;\n    const calculateAggregate = () => {\n        const getCount = () => {\n            value = lookUpObj.get(objKey);\n            // get old value\n            value = value ? value[\"count(\" + columnToAggregate + \")\"] : 0;\n            // add with old value if data exist\n            value += datas[index][columnToAggregate] ? 1 : 0;\n            return value;\n        };\n        const getList = () => {\n            value = lookUpObj.get(objKey);\n            // get old value\n            value = value ? value[\"list(\" + columnToAggregate + \")\"] : [];\n            // push value\n            value.push(datas[index][columnToAggregate]);\n            return value;\n        };\n        const getMax = () => {\n            value = lookUpObj.get(objKey);\n            // get old value\n            value = value ? value[\"max(\" + columnToAggregate + \")\"] : 0;\n            datas[index][columnToAggregate] = datas[index][columnToAggregate] ?\n                datas[index][columnToAggregate] : 0;\n            // compare between old value and new value\n            return value > datas[index][columnToAggregate] ? value : datas[index][columnToAggregate];\n        };\n        const getMin = () => {\n            value = lookUpObj.get(objKey);\n            // get old value\n            value = value ? value[\"min(\" + columnToAggregate + \")\"] : Infinity;\n            datas[index][columnToAggregate] = datas[index][columnToAggregate] ?\n                datas[index][columnToAggregate] : Infinity;\n            // compare between old value and new value\n            return value < datas[index][columnToAggregate] ? value : datas[index][columnToAggregate];\n        };\n        const getSum = () => {\n            value = lookUpObj.get(objKey);\n            // get old value\n            value = value ? value[\"sum(\" + columnToAggregate + \")\"] : 0;\n            // add with old value if data exist\n            value += datas[index][columnToAggregate] ? datas[index][columnToAggregate] : 0;\n            return value;\n        };\n        const getAvg = () => {\n            value = lookUpObj.get(objKey)\n            // get old sum value\n            let sumOfColumn = value ? value[\"sum(\" + columnToAggregate + \")\"] : 0;\n            // add with old value if data exist\n            sumOfColumn += datas[index][columnToAggregate] ? datas[index][columnToAggregate] : 0;\n            datas[index][\"sum(\" + columnToAggregate + \")\"] = sumOfColumn;\n            // get old count value\n            value = value ? value[\"count(\" + columnToAggregate + \")\"] : 0;\n            // add with old value if data exist\n            value += datas[index][columnToAggregate] ? 1 : 0;\n            datas[index][\"count(\" + columnToAggregate + \")\"] = value;\n        };\n        for (const prop in aggregateQry) {\n            const aggregateColumn = aggregateQry[prop];\n            const aggregateValType = getDataType(aggregateColumn);\n            let aggregateCalculator;\n            switch (prop) {\n                case QUERY_OPTION.Count:\n                    aggregateCalculator = getCount;\n                    break;\n                case QUERY_OPTION.Max:\n                    aggregateCalculator = getMax;\n                    break;\n                case QUERY_OPTION.Min:\n                    aggregateCalculator = getMin;\n                    break;\n                case QUERY_OPTION.Sum:\n                    aggregateCalculator = getSum;\n                    break;\n                case QUERY_OPTION.Avg:\n                    aggregateCalculator = getAvg;\n                    break;\n                case QUERY_OPTION.List:\n                    aggregateCalculator = getList;\n                    break;\n            }\n            switch (aggregateValType) {\n                case DATA_TYPE.String:\n                    columnToAggregate = aggregateColumn;\n                    datas[index][`${prop}(${columnToAggregate})`] = aggregateCalculator();\n                    break;\n                case DATA_TYPE.Array:\n                    for (const item in aggregateColumn) {\n                        columnToAggregate = aggregateColumn[item];\n                        datas[index][`${prop}(${columnToAggregate})`] = aggregateCalculator();\n                    }\n            }\n        }\n    };\n\n    if (getDataType(grpQry) === DATA_TYPE.String) {\n        for (index in datas) {\n            objKey = datas[index][grpQry];\n            calculateAggregate();\n            lookUpObj.set(objKey, datas[index]);\n        }\n    }\n    else {\n        for (index in datas) {\n            objKey = \"\";\n            for (const column in grpQry) {\n                objKey += datas[index][grpQry[column]];\n            }\n            calculateAggregate();\n            lookUpObj.set(objKey, datas[index]);\n        }\n\n    }\n    datas = Array.from(lookUpObj.values());\n\n    // Checking for avg and if exist then fill the datas;\n    const avgQuery = aggregateQry.avg;\n    if (avgQuery) {\n        if (getDataType(avgQuery) === DATA_TYPE.String) {\n            for (index in datas) {\n                const sumForAvg = datas[index][\"sum(\" + avgQuery + \")\"],\n                    countForAvg = datas[index][\"count(\" + avgQuery + \")\"];\n                datas[index][\"avg(\" + avgQuery + \")\"] = sumForAvg / countForAvg;\n                if (aggregateQry.count !== avgQuery) {\n                    delete datas[index][\"count(\" + avgQuery + \")\"];\n                }\n                if (aggregateQry.sum !== avgQuery) {\n                    delete datas[index][\"sum(\" + avgQuery + \")\"];\n                }\n            }\n        }\n        else {\n            const isCountTypeString = getDataType(aggregateQry.count) === DATA_TYPE.String;\n            const isSumTypeString = getDataType(aggregateQry.sum) === DATA_TYPE.String;\n            for (index in datas) {\n                for (const column in avgQuery as any) {\n                    const avgColumn = avgQuery[column],\n                        sum = datas[index][\"sum(\" + avgColumn + \")\"],\n                        count = datas[index][\"count(\" + avgColumn + \")\"];\n                    datas[index][\"avg(\" + avgColumn + \")\"] = sum / count;\n\n                    if (isCountTypeString) {\n                        if (aggregateQry.count !== avgColumn) {\n                            delete datas[index][\"count(\" + avgColumn + \")\"];\n                        }\n                        else if (aggregateQry.count.indexOf(avgColumn) === -1) {\n                            delete datas[index][\"count(\" + avgColumn + \")\"];\n                        }\n                    }\n\n                    if (isSumTypeString) {\n                        if (aggregateQry.sum !== avgColumn) {\n                            delete datas[index][\"sum(\" + avgColumn + \")\"];\n                        }\n                        else if (aggregateQry.sum.indexOf(avgColumn) === -1) {\n                            delete datas[index][\"sum(\" + avgColumn + \")\"];\n                        }\n                    }\n                }\n            }\n        }\n    }\n    this.results = datas;\n}\n","import { BaseFetch } from \"../base_fetch\";\nimport { isWhereKeysLengthOne } from \"./is_where_keys_length_one\";\nimport { Count } from \".\";\nimport { promise } from \"@/common\";\n\nexport const onWhereCount = function (this: BaseFetch, onFinish) {\n    return (e) => {\n        const cursor = e.target.result;\n        if (cursor) {\n            if (this.shouldAddValue(cursor)) {\n                ++(this as Count).resultCount;\n            }\n            cursor.continue();\n        }\n        else {\n            onFinish();\n        }\n    }\n}\n\nexport const executeWhereLogic = function (this: BaseFetch, column, value, op) {\n    value = op ? value[op] : value;\n    let cursorRequest;\n\n    const isWhereKeysLengthOneValue = isWhereKeysLengthOne(this.query.where);\n    const objectStore = this.objectStore;\n\n    return promise((res, rej) => {\n        if (isWhereKeysLengthOneValue && objectStore.count) {\n            cursorRequest = objectStore.index(column).count(this.util.keyRange(value, op));\n            cursorRequest.onsuccess = () => {\n                (this as Count).resultCount = cursorRequest.result;\n                res();\n            }\n        }\n        else {\n            cursorRequest = objectStore.index(column).openCursor(this.util.keyRange(value, op));\n            cursorRequest.onsuccess = onWhereCount.call(this, res);\n        }\n        cursorRequest.onerror = rej;\n    });\n}","import { BaseFetch } from \"@executors/base_fetch\";\nimport { Select } from \"@executors/select\";\nimport { ICountQuery, ISelectQuery, IDB_MODE, API, IWhereQuery } from \"@/common\";\nimport { IDBUtil } from \"@/worker/idbutil\";\nimport { QueryHelper } from \"@executors/query_helper\";\nimport { promiseReject, isArray } from \"@worker/utils\";\nimport { executeWhereUndefinedLogic } from \"@executors/count/not_where\";\nimport { executeWhereLogic } from \"./where\";\nimport { executeRegexLogic } from \"./regex\";\nimport { executeInLogic } from \"./in\";\n\nexport class Count extends BaseFetch {\n\n    query: ICountQuery;\n    resultCount: number = 0;\n    executeWhereUndefinedLogic: typeof executeWhereUndefinedLogic;\n\n    constructor(query: ICountQuery, util: IDBUtil) {\n        super();\n        this.query = query;\n        this.util = util;\n        this.tableName = query.from;\n    }\n\n    execute(beforeExecute: () => Promise<any>) {\n        const queryHelper = new QueryHelper(this.db);\n        const query = this.query;\n        const err = queryHelper.validate(API.Count, query);\n        if (err) {\n            return promiseReject(\n                err\n            );\n        }\n        return beforeExecute().then(_ => {\n            let result: Promise<void>;\n            try {\n                const getDataFromSelect = () => {\n                    const selectInstance = new Select(query as ISelectQuery, this.util);\n                    selectInstance.isTxQuery = this.isTxQuery;\n                    return selectInstance.execute().then(results => {\n                        this.resultCount = results.length;\n                    });\n                };\n                this.initTransaction_();\n                if (query.join == null) {\n                    if (query.where != null) {\n                        if ((query.where as IWhereQuery).or || isArray(query.where)) {\n                            result = getDataFromSelect();\n                        }\n                        else {\n                            this.shouldAddValue = (cursor) => {\n                                return this.whereChecker.check(cursor.value);\n                            };\n                            result = this.goToWhereLogic();\n                        }\n                    }\n                    else {\n                        result = this.executeWhereUndefinedLogic() as any;\n                    }\n                }\n                else {\n                    result = getDataFromSelect();\n                }\n            }\n            catch (ex) {\n                this.onException(ex);\n            }\n            return result.then(_ => {\n                return this.resultCount;\n            })\n        });\n    }\n\n    private initTransaction_() {\n        const tableName = this.query.from;\n        if (!this.isTxQuery) {\n            this.util.createTransaction([tableName], IDB_MODE.ReadOnly);\n        }\n        this.objectStore = this.util.objectStore(tableName);\n    }\n}\n\nCount.prototype.executeWhereUndefinedLogic = executeWhereUndefinedLogic;\nCount.prototype.executeWhereLogic = executeWhereLogic\nCount.prototype.executeRegexLogic = executeRegexLogic\nCount.prototype.executeInLogic = executeInLogic","import { promise } from \"@/common\";\nimport { BaseFetch } from \"../base_fetch\";\nimport { Count } from \".\";\n\nexport const executeWhereUndefinedLogic = function (this: BaseFetch) {\n    let countRequest;\n    const objectStore = this.objectStore;\n    const onSuccess = (() => {\n        if (objectStore.count) {\n            countRequest = objectStore.count();\n            return (onFinish) => {\n                return () => {\n                    (this as Count).resultCount = countRequest.result;\n                    onFinish();\n                }\n            }\n        }\n        else {\n            let cursor;\n            countRequest = objectStore.openCursor();\n            return (onFinish) => {\n                return (e: any) => {\n                    cursor = e.target.result;\n                    if (cursor) {\n                        ++(this as Count).resultCount;\n                        cursor.continue();\n                    }\n                    else {\n                        onFinish();\n                    }\n                };\n            };\n        }\n    })();\n    return promise((res, rej) => {\n        countRequest.onerror = rej;\n        countRequest.onsuccess = onSuccess(res);\n    });\n}\n","import { BaseFetch } from \"../base_fetch\";\nimport { promise } from \"@/common\";\nimport { onWhereCount } from \"./where\";\n\nexport const executeRegexLogic = function (this: BaseFetch, column: string, exp: RegExp) {\n    const cursorRequest = this.objectStore.index(column).openCursor();\n    this.shouldAddValue = (cursor) => {\n        return exp.test(cursor.key) &&\n            this.whereChecker.check(cursor.value);\n    };\n    return promise((res, rej) => {\n        cursorRequest.onerror = rej;\n        cursorRequest.onsuccess = onWhereCount.call(this, res);\n    })\n}","import { promise, promiseAll } from \"@/common\";\nimport { BaseFetch } from \"../base_fetch\";\nimport { onWhereCount } from \"./where\";\nimport { isWhereKeysLengthOne } from \"./is_where_keys_length_one\";\n\n\nexport const executeInLogic = function (this: BaseFetch, column, values) {\n    const objectStore = this.objectStore;\n    const columnStore = objectStore.index(column);\n    const isWhereKeysLengthOneValue = isWhereKeysLengthOne(this.query.where);\n\n    const runInLogic: (val) => Promise<void> = (value) => {\n        const keyRange = this.util.keyRange(value);\n        if (isWhereKeysLengthOneValue && objectStore.count) {\n            return promise((res, rej) => {\n                const cursorRequest = columnStore.count(keyRange);\n                cursorRequest.onsuccess = (e: any) => {\n                    this.resultCount += e.target.result;\n                    res();\n                };\n                cursorRequest.onerror = rej;\n            });\n        }\n        return promise<void>((res, rej) => {\n            const cursorRequest = columnStore.openCursor(keyRange);\n            cursorRequest.onsuccess = onWhereCount.call(this, res);\n            cursorRequest.onerror = rej;\n        });\n    };\n\n    return promiseAll<void>(\n        values.map(function (val) {\n            return runInLogic(val);\n        })\n    );\n}\n","import { isArray } from \"./is_array\";\n\nexport const variableFromPath = (path: string) => {\n    const properties: string[] = isArray(path) ? path as any : path.split(\".\");\n    return properties.reduce((prev, curr) => prev && prev[curr], self);\n}","import { getDataType, variableFromPath, promiseReject, LogHelper } from \"@worker/utils\";\nimport { DATA_TYPE, ERROR_TYPE, IUpdateQuery } from \"@/common\";\n\nexport const updateValue = (query: IUpdateQuery, storedValue) => {\n    let setValue = query.set;\n    const mapSet = query.mapSet;\n    if (mapSet) {\n        const result = (mapSet as Function)(setValue, storedValue);\n        if (result != null) {\n            setValue = result;\n        }\n    }\n    for (const key in setValue) {\n        const columnSetValue = setValue[key];\n        if (getDataType(columnSetValue) !== DATA_TYPE.Object) {\n            storedValue[key] = columnSetValue;\n        }\n        else {\n            for (const op in columnSetValue) {\n                let value = columnSetValue[op];\n                switch (op as any) {\n                    case '+': storedValue[key] += value; break;\n                    case '-': storedValue[key] -= value; break;\n                    case '*': storedValue[key] *= value; break;\n                    case '/': storedValue[key] /= value; break;\n                    case '{push}': storedValue[key].push(value); break;\n                    default: storedValue[key] = columnSetValue;\n                }\n                break;\n            }\n        }\n    }\n    return storedValue;\n};","import { IUpdateQuery, ISelectQuery, QUERY_OPTION, API, IWhereQuery, DATA_TYPE, ERROR_TYPE, promiseAll } from \"@/common\";\nimport { IDBUtil } from \"@/worker/idbutil\";\nimport { QueryHelper } from \"../query_helper\";\nimport { promiseReject, isArray, getDataType, variableFromPath, LogHelper } from \"@worker/utils\";\nimport { BaseFetch } from \"@executors/base_fetch\";\nimport { Select } from \"@executors/select\";\nimport { executeWhereUndefinedLogic } from \"./not_where\";\nimport { executeInLogic } from \"./in\";\nimport { executeRegexLogic } from \"./regex\";\nimport { executeWhereLogic } from \"./where\";\n\nexport class Update extends BaseFetch {\n    executeWhereUndefinedLogic: typeof executeWhereUndefinedLogic\n\n    constructor(query: IUpdateQuery, util: IDBUtil) {\n        super();\n        query.returnImmediate = query.returnImmediate == null ? false : query.returnImmediate;\n        this.query = query as any;\n        this.util = util;\n        this.tableName = query.in;\n        const mapSet = query.mapSet;\n        if (mapSet) {\n            const method = getDataType(mapSet) === DATA_TYPE.String ?\n                variableFromPath(mapSet as string) : mapSet;\n            if (!method) {\n                throw new LogHelper(ERROR_TYPE.MethodNotExist, mapSet);\n            }\n            query.mapSet = method;\n        }\n\n    }\n\n    execute(beforeExecute: () => Promise<any>) {\n        const query: IUpdateQuery = this.query as any;\n        try {\n            const queryHelper = new QueryHelper(this.db);\n            const err = queryHelper.validate(API.Update, query);\n            if (err) return promiseReject(err);\n            return beforeExecute().then(_ => {\n                const txPromise = this.initTransaction();\n                let pResult: Promise<void>;\n                if (query.where != null) {\n                    if ((query.where as IWhereQuery).or || isArray(query.where)) {\n                        pResult = this.executeComplexLogic_();\n                    }\n                    else {\n                        pResult = this.goToWhereLogic();\n                    }\n                }\n                else {\n                    pResult = this.executeWhereUndefinedLogic();\n                }\n                const promiseToUse = [pResult];\n                if (query.returnImmediate === false && txPromise) {\n                    promiseToUse.push(txPromise);\n                }\n                return promiseAll(promiseToUse).then(() => {\n                    return this.rowAffected;\n                })\n            })\n        }\n        catch (ex) {\n            return this.onException(ex);\n        }\n    }\n\n    private executeComplexLogic_() {\n        const query: IUpdateQuery = this.query as any;\n        const selectObject = new Select({\n            from: query.in,\n            where: query.where,\n            ignoreCase: query.ignoreCase\n        } as ISelectQuery, this.util);\n        selectObject.isTxQuery = this.isTxQuery;\n        return selectObject.execute().then((results: any[]) => {\n            const key = this.primaryKey(query.in);\n            const inQuery = [];\n            results.forEach((value) => {\n                inQuery.push(value[key]);\n            });\n            results = null;\n            const whereQry = { [key]: { [QUERY_OPTION.In]: inQuery } };\n            this.query.where = whereQry;\n            // this.initTransaction();\n            return this.goToWhereLogic();\n        });\n    }\n\n    private initTransaction() {\n        const tableName = (this.query as any).in;\n        let promise: Promise<void>;\n        if (!this.isTxQuery) {\n            promise = this.util.createTransaction([tableName]);\n        }\n        this.objectStore = this.util.objectStore(tableName);\n        return promise;\n    }\n}\n\nUpdate.prototype.executeWhereUndefinedLogic = executeWhereUndefinedLogic;\nUpdate.prototype.executeWhereLogic = executeWhereLogic\nUpdate.prototype.executeRegexLogic = executeRegexLogic\nUpdate.prototype.executeInLogic = executeInLogic\n","import { Update } from \"./\";\nimport { promise } from \"@/common\";\nimport { updateValue } from \"./update_value\";\n\n\nexport const executeWhereUndefinedLogic = function (this: Update) {\n    const cursorRequest: IDBRequest<IDBCursorWithValue> = this.objectStore.openCursor();\n    return promise<void>((res, rej) => {\n        cursorRequest.onsuccess = (e: any) => {\n            const cursor: IDBCursorWithValue = (e as any).target.result;\n            if (cursor) {\n                try {\n                    const cursorUpdateRequest = cursor.update(updateValue(this.query as any, cursor.value));\n                    cursorUpdateRequest.onsuccess = () => {\n                        ++this.rowAffected;\n                        cursor.continue();\n                    };\n                    cursorUpdateRequest.onerror = rej;\n                } catch (ex) {\n                    rej(\n                        ex\n                    );\n                }\n            }\n            else {\n                res();\n            }\n        };\n        cursorRequest.onerror = rej;\n    })\n\n}\n","import { promise, IUpdateQuery } from \"@/common\";\nimport { updateValue } from \"./update_value\";\nimport { Update } from \"./\";\n\nexport const executeWhereLogic = function (this: Update, column, value, op) {\n    const query: IUpdateQuery = this.query as any;\n    value = op ? value[op] : value;\n    const cursorRequest = this.objectStore.index(column).openCursor(this.util.keyRange(value, op));\n    return promise<void>((res, rej) => {\n        cursorRequest.onsuccess = (e: any) => {\n            const cursor: IDBCursorWithValue = e.target.result;\n            if (cursor) {\n                if (this.whereChecker.check(cursor.value)) {\n                    try {\n                        const cursorUpdateRequest = cursor.update(updateValue(query, cursor.value));\n                        cursorUpdateRequest.onsuccess = () => {\n                            ++this.rowAffected;\n                            cursor.continue();\n                        };\n                        cursorUpdateRequest.onerror = rej;\n                    } catch (ex) {\n                        rej(\n                            ex\n                        );\n                    }\n                }\n                else {\n                    cursor.continue();\n                }\n            }\n            else {\n                res();\n            }\n        };\n        cursorRequest.onerror = rej\n    })\n}","import { Update } from \"./\";\nimport { updateValue } from \"./update_value\";\nimport { promise } from \"@/common\";\n\nexport const executeRegexLogic = function (this: Update, column: string, exp: RegExp) {\n    let cursor: IDBCursorWithValue;\n    const cursorOpenRequest = this.objectStore.index(column).openCursor();\n    this.shouldAddValue = (cursor) => {\n        return exp.test(cursor.key) &&\n            this.whereChecker.check(cursor.value);\n    };\n    return promise<void>((res, rej) => {\n\n        cursorOpenRequest.onsuccess = (e: any) => {\n            cursor = e.target.result;\n            if (cursor) {\n                if (this.shouldAddValue(cursor)) {\n                    try {\n                        const cursorUpdateRequest = cursor.update(updateValue(this.query as any, cursor.value));\n                        cursorUpdateRequest.onsuccess = () => {\n                            ++this.rowAffected;\n                            cursor.continue();\n                        };\n                        cursorUpdateRequest.onerror = rej;\n                    } catch (ex) {\n                        rej(\n                            ex\n                        );\n                    }\n                }\n                else {\n                    cursor.continue();\n                }\n\n            }\n            else {\n                res();\n            }\n        };\n        cursorOpenRequest.onerror = rej;\n    })\n\n}\n","import { Update } from \"./\";\nimport { promiseAll, promise, IUpdateQuery } from \"@/common\";\nimport { updateValue } from \"./update_value\";\n\n\nexport const executeInLogic = function (this: Update, column, values: any[]) {\n    const columnStore = this.objectStore.index(column);\n    const query: IUpdateQuery = this.query as any;\n    const runInLogic: (val) => Promise<void> = (value) => {\n        return promise((res, rej) => {\n            const cursorRequest = columnStore.openCursor(this.util.keyRange(value));\n            cursorRequest.onsuccess = (e: any) => {\n                const cursor: IDBCursorWithValue = e.target.result;\n                if (cursor) {\n                    const value = cursor.value;\n                    if (this.whereChecker.check(value)) {\n                        try {\n                            const cursorUpdateRequest = cursor.update(updateValue(query, value));\n                            cursorUpdateRequest.onsuccess = () => {\n                                ++this.rowAffected;\n                                cursor.continue();\n                            };\n                            cursorUpdateRequest.onerror = rej;\n                        }\n                        catch (ex) {\n                            rej(\n                                ex\n                            );\n                        }\n\n                    }\n                    else {\n                        cursor.continue();\n                    }\n                }\n                else {\n                    res();\n                }\n            };\n            cursorRequest.onerror = rej;\n        });\n    };\n\n    return promiseAll<void>(\n        values.map(function (val) {\n            return runInLogic(val);\n        })\n    );\n}\n","import { IIntersectQuery, ISelectQuery } from \"@/common\";\nimport { Base } from \"@executors/base\";\nimport { Select } from \"@executors/select\";\n\nexport class Intersect extends Base {\n\n    constructor(intersectQry: IIntersectQuery, util) {\n        super();\n        this.query = intersectQry as any;\n        this.util = util;\n    }\n\n    execute() {\n        const intersectQry: IIntersectQuery = this.query as any;\n        let index = 0;\n        let hashMap = {};\n        let hashMapTemp = {};\n        let isQueryForSameTable = true;\n        const queries = intersectQry.queries;\n        const queryLength = queries.length;\n        queries.every((qry, i) => {\n            if (i + 1 < queryLength && qry.from !== queries[i + 1].from) {\n                isQueryForSameTable = false;\n                return false;\n            }\n            return true;\n        });\n        let getHashKey;\n        if (isQueryForSameTable) {\n            const pKey = this.primaryKey(queries[0].from);\n            getHashKey = (val) => {\n                return val[pKey];\n            };\n        }\n        else {\n            getHashKey = (val) => {\n                let columnValKey = \"\";\n                for (const key in val) {\n                    columnValKey += val[key];\n                }\n                return columnValKey;\n            };\n        }\n\n        let select: Select;\n        const fetchData = () => {\n            if (index < queryLength) {\n                select = new Select(queries[index], this.util);\n                return select.execute().then((selectResult) => {\n                    hashMap = {};\n                    selectResult.forEach(val => {\n                        const columnValKey = getHashKey(val);\n                        if (index === 0) {\n                            hashMapTemp[columnValKey] = val;\n                        } else if (hashMapTemp[columnValKey] != null) {\n                            hashMap[columnValKey] = val;\n                        }\n                    });\n                    if (index > 0) {\n                        hashMapTemp = { ...hashMap };\n                    }\n\n                    ++index;\n                    return fetchData();\n                })\n            }\n            else {\n                const results = [];\n                let resultPusher: (key: string) => void;\n                let skip = intersectQry.skip;\n                const limit = intersectQry.limit;\n                const onFinished = () => {\n                    select['results'] = results;\n                    Object.assign(select.query, {\n                        order: intersectQry.order,\n                        join: {} as any\n                    } as ISelectQuery);\n                    select.processOrderBy();\n                    select.processGroupDistinctAggr();\n                    return (select['results']);\n                };\n                let shouldStopLoop = false;\n                let key: string;\n                const pushResult = () => {\n                    results.push(hashMap[key]);\n                };\n                const checkLimitAndPush = () => {\n                    if (results.length < limit) {\n                        pushResult();\n                    }\n                    else {\n                        shouldStopLoop = true;\n                    }\n                };\n                const skipChecker = (callBack: () => void) => {\n                    if (skip === 0) {\n                        callBack();\n                    }\n                    else {\n                        --skip;\n                    }\n                };\n                if (intersectQry.skip && intersectQry.limit) {\n                    resultPusher = () => {\n                        skipChecker(() => {\n                            checkLimitAndPush();\n                        });\n                    };\n\n                }\n                else if (intersectQry.limit) {\n                    resultPusher = checkLimitAndPush;\n                }\n                else if (intersectQry.skip) {\n                    resultPusher = () => {\n                        skipChecker(() => {\n                            pushResult();\n                        });\n                    };\n                }\n                else {\n                    resultPusher = () => {\n                        pushResult();\n                    };\n                }\n                if (limit) {\n                    for (key in hashMap) {\n                        resultPusher(key);\n                        if (shouldStopLoop) {\n                            break;\n                        }\n                    }\n                }\n                else {\n                    for (key in hashMap) {\n                        resultPusher(key);\n                    }\n                }\n                return onFinished();\n            }\n        };\n        return fetchData();\n    }\n}","import { LogHelper, getError } from \"@worker/utils\";\nimport { ERROR_TYPE, promise } from \"@/common\";\n\nexport class DropDb {\n\n    execute(dbName: string) {\n        return promise((res, rej) => {\n            const dropDbRequest = indexedDB.deleteDatabase(dbName);\n            dropDbRequest.onblocked = () => {\n                const err = new LogHelper(ERROR_TYPE.DbBlocked);\n                return rej(\n                    getError(err)\n                );\n            };\n            dropDbRequest.onerror = (e) => {\n                return rej(\n                    getError(e)\n                )\n            };\n            dropDbRequest.onsuccess = () => {\n                res();\n            };\n        })\n    }\n}\n","import { Base } from \"@executors/base\";\nimport { ISelectQuery } from \"@/common\";\nimport { Select } from \"@executors/select\";\nimport { IDBUtil } from \"@/worker/idbutil\";\n\nexport class Union extends Base {\n\n    constructor(query: ISelectQuery[], util: IDBUtil) {\n        super();\n        this.query = query as any;\n        this.util = util;\n    }\n\n    execute() {\n        const query: ISelectQuery[] = this.query as any;\n        let index = 0;\n        const hashMap = new Map();\n        let isQueryForSameTable = true;\n        const queryLength = query.length;\n        query.every((qry, i) => {\n            if (i + 1 < queryLength && qry.from !== query[i + 1].from) {\n                isQueryForSameTable = false;\n                return false;\n            }\n            return true;\n        });\n        let getHashKey;\n        if (isQueryForSameTable) {\n            const pKey = this.primaryKey(query[0].from);\n            getHashKey = (val) => {\n                return val[pKey];\n            };\n        }\n        else {\n            getHashKey = (val) => {\n                let columnValKey = \"\";\n                for (const key in val) {\n                    columnValKey += val[key];\n                }\n                return columnValKey;\n            };\n        }\n        let select: Select;\n        const fetchData = () => {\n            if (index < query.length) {\n                select = new Select(query[index++], this.util);\n                return select.execute().then((selectResult) => {\n                    selectResult.forEach(val => {\n                        hashMap.set(getHashKey(val), val);\n                    });\n                    return fetchData();\n                })\n            }\n            else {\n                return Array.from(hashMap.values());\n            }\n        };\n        return fetchData();\n    }\n\n\n}","import { Remove } from \".\";\nimport { promise } from \"@/common\";\n\nexport const onWhereRemove = function (this: Remove, onFinish) {\n    return (e) => {\n        const cursor: IDBCursorWithValue = e.target.result;\n        if (cursor) {\n            if (this.shouldAddValue(cursor.value)) {\n                cursor.delete();\n                ++this.rowAffected;\n            }\n            cursor.continue();\n        }\n        else {\n            onFinish();\n        }\n    };\n}\n\nexport const executeWhereLogic = function (this: Remove, column, value, op) {\n    value = op ? value[op] : value;\n    const cursorRequest = this.objectStore.index(column).openCursor(this.util.keyRange(value, op));\n\n\n    return promise<void>((res, rej) => {\n        cursorRequest.onsuccess = onWhereRemove.call(this, res);\n        cursorRequest.onerror = rej\n    })\n\n}\n\n","import { BaseFetch } from \"../base_fetch\";\nimport { IRemoveQuery, QUERY_OPTION, API, IWhereQuery } from \"@/common\";\nimport { IDBUtil } from \"@/worker/idbutil\";\nimport { QueryHelper } from \"@executors/query_helper\";\nimport { promiseReject, isArray, getObjectFirstKey } from \"@/worker/utils\";\nimport { Select } from \"@executors/select\";\nimport { executeWhereUndefinedLogic } from \"./not_where\";\nimport { executeInLogic } from \"./in\";\nimport { executeWhereLogic } from \"./where\";\nimport { executeRegexLogic } from \"./regex\";\n\nexport class Remove extends BaseFetch {\n    isOr;\n    executeWhereUndefinedLogic;\n\n    constructor(\n        query: IRemoveQuery, util: IDBUtil\n    ) {\n        super();\n        this.query = query;\n        this.util = util;\n        this.tableName = query.from;\n    }\n\n    execute(beforeExecute: () => Promise<any>) {\n        const queryHelper = new QueryHelper(this.db);\n        const query = this.query;\n        const err = queryHelper.validate(API.Remove, query);\n        if (err) return promiseReject(\n            err\n        );\n        let pResult: Promise<void>;\n        return beforeExecute().then(_ => {\n            try {\n                this.initTransaction_();\n                if (query.where != null) {\n                    if (isArray(query.where)) {\n                        pResult = this.processWhereArrayQry();\n                    }\n                    else {\n                        pResult = this.processWhere_();\n                    }\n                }\n                else {\n                    pResult = this.executeWhereUndefinedLogic();\n                }\n\n            }\n            catch (ex) {\n                return this.onException(ex);\n            }\n            return pResult.then(() => {\n                return this.rowAffected;\n            })\n        })\n    }\n\n    private processWhereArrayQry() {\n        const selectObject = new Select(this.query, this.util);\n        selectObject.isTxQuery = this.isTxQuery;\n        return selectObject.execute().then((results) => {\n            const keyList = [];\n            const pkey = this.primaryKey(this.query.from);\n            results.forEach((item) => {\n                keyList.push(item[pkey]);\n            });\n            results = null;\n            const whereQry = { [pkey]: { [QUERY_OPTION.In]: keyList } };\n            this.query[QUERY_OPTION.Where] = whereQry;\n            return this.processWhere_();\n        })\n    }\n\n    private processWhere_() {\n        this.shouldAddValue = (value) => {\n            return this.whereChecker.check(value);\n        };\n        if ((this.query.where as IWhereQuery).or) {\n            this.processOrLogic();\n        }\n        return this.goToWhereLogic().then(() => {\n            return this.onWhereEvaluated();\n        });\n    }\n\n    private initTransaction_() {\n        if (!this.isTxQuery) {\n            this.util.createTransaction([this.query.from]);\n        }\n        this.objectStore = this.util.objectStore(this.query.from);\n    }\n\n    private onWhereEvaluated() {\n        if (this.isOr) {\n            return this.orQuerySuccess_();\n        }\n    }\n\n    private orQuerySuccess_() {\n        const orQueryFromOrInfo = (this as any)._orInfo.OrQuery\n        const key = getObjectFirstKey(orQueryFromOrInfo);\n        if (key != null) {\n            const where = {};\n            where[key] = orQueryFromOrInfo[key];\n            delete orQueryFromOrInfo[key];\n            this.query.where = where;\n            return this.goToWhereLogic().then(() => {\n                return this.onWhereEvaluated();\n            })\n        }\n        else {\n            this.isOr = true;\n        }\n    }\n\n    private processOrLogic() {\n        this.isOr = true;\n        const where = this.query.where as IWhereQuery;\n        (this as any)._orInfo = {\n            OrQuery: where.or\n        };\n\n        // free or memory\n        delete where.or;\n    }\n}\n\nRemove.prototype.executeInLogic = executeInLogic;\nRemove.prototype.executeWhereUndefinedLogic = executeWhereUndefinedLogic;\nRemove.prototype.executeWhereLogic = executeWhereLogic;\nRemove.prototype.executeRegexLogic = executeRegexLogic;","import { Remove } from \".\";\nimport { promise, promiseAll } from \"@/common\";\nimport { onWhereRemove } from \"./where\";\n\nexport const executeInLogic = function (this: Remove, column, values) {\n    const columnIndex = this.objectStore.index(column)\n    const runInLogic: (val) => Promise<void> = (value) => {\n        return promise((res, rej) => {\n            const cursorRequest = columnIndex.openCursor(this.util.keyRange(value));\n            cursorRequest.onsuccess = onWhereRemove.call(this, res);\n            cursorRequest.onerror = rej;\n        });\n    };\n\n    return promiseAll<void>(\n        values.map(function (val) {\n            return runInLogic(val);\n        })\n    );\n}\n","import { Remove } from \".\";\nimport { promise } from \"@/common\";\n\nexport const executeWhereUndefinedLogic = function (this: Remove) {\n    let cursor;\n    const cursorRequest = this.objectStore.openCursor();\n    return promise<void>((res, rej) => {\n        cursorRequest.onsuccess = (e: any) => {\n            cursor = e.target.result;\n            if (cursor) {\n                cursor.delete();\n                ++this.rowAffected;\n                (cursor as any).continue();\n            }\n            else {\n                res();\n            }\n        };\n        cursorRequest.onerror = rej;\n    })\n\n}\n","import { Remove } from \"./\";\nimport { promise } from \"@/common\";\n\nexport const executeRegexLogic = function (this: Remove, column: string, exp: RegExp) {\n    let cursor: IDBCursorWithValue;\n    const cursorRequest = this.objectStore.index(column).openCursor();\n    this.shouldAddValue = (cursor) => {\n        return exp.test(cursor.key) &&\n            this.whereChecker.check(cursor.value);\n    };\n    return promise<void>((res, rej) => {\n        cursorRequest.onsuccess = (e: any) => {\n            cursor = e.target.result;\n            if (cursor) {\n                if (this.shouldAddValue(cursor)) {\n                    cursor.delete();\n                    ++this.rowAffected;\n                }\n                cursor.continue();\n            }\n            else {\n                res();\n            }\n        };\n        cursorRequest.onerror = rej;\n    })\n\n}","import { Base } from \"@executors/base\";\nimport { IDBUtil } from \"@/worker/idbutil\";\nimport { MetaHelper } from \"@/worker/meta_helper\";\nimport { promise } from \"@/common\";\n\nexport class Clear extends Base {\n    constructor(tableName: string, util: IDBUtil) {\n        super();\n        this.query = tableName as any;\n        this.util = util;\n        this.tableName = tableName;\n    }\n\n    execute(beforeExecute: () => Promise<any>) {\n        const tableName: string = this.query as any;\n        if (!this.isTxQuery) {\n            this.util.createTransaction([tableName, MetaHelper.tableName]);\n        }\n        return beforeExecute().then(_ => {\n            const clearRequest: IDBRequest = this.util.objectStore(tableName).clear();\n            try {\n                return promise<void>((res, rej) => {\n                    clearRequest.onsuccess = (e) => {\n                        const currentTable = this.table(tableName);\n                        for (const columnName in currentTable.autoIncColumnValue) {\n                            currentTable.autoIncColumnValue[columnName] = 0;\n                        }\n                        MetaHelper.set(MetaHelper.dbSchema, this.util.db, this.util).then(res).catch(rej);\n                    };\n\n                    clearRequest.onerror = rej;\n                })\n            }\n            catch (ex) {\n                return this.onException(ex);\n            }\n        })\n    }\n}","import { Base } from \"@executors/base\";\nimport { ITransactionQuery, WebWorkerRequest, ERROR_TYPE, API, WebWorkerResult, promise } from \"@/common\";\nimport { IDBUtil } from \"@worker/idbutil\";\nimport { promiseReject, LogHelper, variableFromPath } from \"@worker/utils\";\nimport { Insert } from \"@executors/insert\";\nimport { Select } from \"@executors/select\";\nimport { Count } from \"@executors/count\";\nimport { Update } from \"@executors/update\";\nimport { Remove } from \"@executors/remove\";\nimport { IQueryExecutor } from \"@/worker/interfaces\";\nimport { MetaHelper } from \"@/worker/meta_helper\";\n\nexport class Transaction extends Base {\n    results = {} as any;\n    reqQueue: WebWorkerRequest[] = [];\n    isQueryExecuting = false;\n\n    isTxStarted_ = false;\n\n    onSuccess: (result: any) => void;\n    onError: (err: LogHelper) => void;\n\n    beforeExecute: () => Promise<void>;\n\n    constructor(qry: ITransactionQuery, util: IDBUtil) {\n        super();\n        this.query = qry as any;\n        this.util = util;\n    }\n\n    execute(cb: () => Promise<void>) {\n        this.beforeExecute = cb;\n        const err = this.validate();\n        if (err) return promiseReject(\n            err\n        );\n        this.startExecution_()\n\n        return promise<void>((res, rej) => {\n            this.onSuccess = res;\n            this.onError = rej;\n        }).then(result => {\n            this.beforeExecute = null;\n            this.log(`transaction finished`);\n            return result;\n        })\n    }\n\n    validate() {\n        const query: ITransactionQuery = this.query as any;\n        const notExistingTable = this.notExistingTable_(query.tables);\n        if (notExistingTable) {\n            return new LogHelper(ERROR_TYPE.TableNotExist, { tableName: notExistingTable });\n        }\n        const methodName = query.method;\n        let txLogic = variableFromPath(methodName);\n        if (!txLogic) {\n            return new LogHelper(ERROR_TYPE.MethodNotExist, methodName);\n        }\n    }\n\n    private startExecution_() {\n        const query: ITransactionQuery = this.query as any;\n        const createPusher = (api: any) => {\n            return (qry) => {\n                return this.pushReq_({\n                    name: api,\n                    query: qry\n                } as WebWorkerRequest);\n            }\n        };\n        const setResult = (key: string, value) => {\n            this.results[key] = value;\n        };\n        const getResult = (key: string) => {\n            return this.results[key];\n        };\n        const abort = (msg: string) => {\n            this.abortTx_(msg);\n        };\n\n        const start = () => {\n            this.startTx_();\n        };\n        const methodName = query.method\n        let txLogic = variableFromPath(methodName);\n\n        this.log(`transaction query started`);\n\n        return txLogic.call(\n            this,\n            {\n                data: query.data,\n                insert: createPusher(API.Insert),\n                select: createPusher(API.Select),\n                update: createPusher(API.Update),\n                remove: createPusher(API.Remove),\n                count: createPusher(API.Count),\n                setResult: setResult,\n                getResult: getResult, abort: abort,\n                start: start\n            }\n        );\n    }\n\n    log(message) {\n        this.util.logger.log(message);\n    }\n\n    private startTx_() {\n        try {\n            this.isTxStarted_ = true;\n            let tableNames = (this.query as any).tables as string[];\n            tableNames = tableNames.concat(MetaHelper.tableName)\n            this.util.createTransaction(tableNames).then(_ => {\n                this.onSuccess(this.results);\n            }).catch(err => {\n                this.onError(err);\n            })\n            return this.processExecutionOfQry_();\n        }\n        catch (ex) {\n            this.onError(this.onException(ex) as any);\n        }\n    }\n\n\n\n\n\n    private onReqFinished_(result) {\n        const finisehdRequest = this.reqQueue.shift();\n\n        this.log(`finished request : ${finisehdRequest.name} `);\n\n        if (finisehdRequest) {\n            if (result.error) {\n                this.abortTx_(\"automatic abort of transaction due to error occured\");\n                this.log(`transaction aborted due to error occured`);\n                this.onError(result.error);\n            }\n            else {\n                this.isQueryExecuting = false;\n                if (finisehdRequest.onSuccess) {\n                    finisehdRequest.onSuccess(result);\n                }\n                this.processExecutionOfQry_();\n            }\n        }\n    }\n\n    private abortTx_(msg: string) {\n        this.reqQueue = [];\n        this.util.abortTransaction();\n        this.log(`transaction aborted. Msg : ${msg}`);\n\n    }\n\n    private executeRequest_(request: WebWorkerRequest) {\n        this.isQueryExecuting = true;\n        let requestObj: IQueryExecutor;\n        this.log(`executing request : ${request.name} `);\n        const onReqFinished = this.onReqFinished_.bind(this);\n        const query = request.query;\n\n        const callAPI = (api: typeof Select) => {\n            query.returnImmediate = true;\n            requestObj = new api(\n                query, this.util\n            );\n        };\n\n        switch (request.name) {\n            case API.Select:\n                callAPI(Select);\n                break;\n            case API.Insert:\n                callAPI(Insert as any);\n                break;\n            case API.Update:\n                callAPI(Update as any);\n                break;\n            case API.Remove:\n                callAPI(Remove as any);\n                break;\n            case API.Count:\n                callAPI(Count as any);\n                break;\n        }\n        requestObj.isTxQuery = true;\n        requestObj.execute(this.beforeExecute).then(onReqFinished).catch(err => {\n            const result = {\n                error: err\n            } as WebWorkerResult;\n            onReqFinished(result);\n        })\n    }\n\n    private pushReq_(request: WebWorkerRequest) {\n        const promiseObj = promise((resolve, reject) => {\n            request.onSuccess = (result) => {\n                resolve(result);\n            };\n            request.onError = (error) => {\n                reject(error);\n            };\n        });\n        this.reqQueue.push(request);\n        if (this.isTxStarted_ === true) {\n            this.processExecutionOfQry_();\n        }\n\n        this.log(`request pushed : ${request.name}`);\n        return promiseObj;\n    }\n\n    private processExecutionOfQry_() {\n        if (this.isQueryExecuting === false) {\n            if (this.reqQueue.length > 0) {\n                this.executeRequest_(this.reqQueue[0]);\n            }\n        }\n    }\n\n    private notExistingTable_(tables: string[]) {\n        let invalidTable: string = null;\n        tables.every(tableName => {\n            const table = this.table(tableName);\n            if (table == null) {\n                invalidTable = tableName;\n                return false;\n            }\n            return true;\n        });\n        return invalidTable;\n    }\n}\n","import { DbMeta } from \"@worker/model\";\nimport { IDataBase, ITable } from \"@/common\";\n\nexport const userDbSchema = (db: DbMeta) => {\n    if (db == null) {\n        throw new Error(`userDbSchema db is null`);\n    }\n    const database = {\n        name: db.name,\n        version: db.version,\n        tables: []\n    } as IDataBase;\n    db.tables.forEach(table => {\n        const tableAsObj = {\n            name: table.name,\n            columns: {}\n        } as ITable;\n        table.columns.forEach(column => {\n            tableAsObj.columns[column.name] = column;\n        });\n        database.tables.push(tableAsObj);\n    })\n    return database;\n}","import { WebWorkerRequest, promiseResolve, API, IDataBase, WebWorkerResult, promise, ERROR_TYPE, IDbInfo, InitDbResult } from \"@/common\";\nimport { DbMeta } from \"./model\";\nimport { IDBUtil } from \"./idbutil\";\nimport { Insert } from \"@executors/insert\";\nimport { IS_WORKER, IS_IDB_SUPPORTED } from \"./constants\";\nimport { MetaHelper } from \"./meta_helper\";\nimport { Select } from \"@executors/select\";\nimport { Count } from \"@executors/count\";\nimport { Update } from \"@executors/update\";\nimport { Intersect } from \"./intersect\";\nimport { DropDb } from \"@executors/drop_db\";\nimport { Union } from \"./union\";\nimport { Remove } from \"@executors/remove\";\nimport { Clear } from \"@executors/clear\";\nimport { Transaction } from \"@executors/transaction\";\nimport { LogHelper, getError, promiseReject, variableFromPath, userDbSchema, getLength } from \"@worker/utils\";\n\nexport class QueryManager {\n    util: IDBUtil;\n\n    get db() {\n        return this.util.db;\n    }\n\n    middlewares: string[] = [];\n\n    private onQryFinished;\n\n    protected get logger() {\n        return this.util.logger;\n    }\n\n    constructor(fn?: (result: any) => void) {\n        this.util = new IDBUtil();\n        this.onQryFinished = IS_WORKER ? (result) => {\n            self.postMessage(result);\n        } : fn;\n    }\n\n    private executeMiddleware_(request: WebWorkerRequest) {\n        const lastIndex = (getLength(this.middlewares) as any) - 1;\n        if (lastIndex < 0) {\n            return promiseResolve();\n        }\n        const middlewareContext = {};\n        const db = this.db;\n        Object.defineProperty(middlewareContext, 'database', {\n            get() {\n                return userDbSchema(db);\n            }\n        });\n        return promise<void>((res) => {\n            let index = 0;\n            const callNextMiddleware = () => {\n                if (index <= lastIndex) {\n                    let promiseResult = variableFromPath(this.middlewares[index++])(request, middlewareContext);\n                    if (!promiseResult || !promiseResult.then) {\n                        promiseResult = Promise.resolve(promiseResult);\n                    }\n                    promiseResult.then(_ => {\n                        callNextMiddleware();\n                    });\n                }\n                else {\n                    res();\n                }\n            };\n            callNextMiddleware();\n        });\n    }\n\n    executeQuery(request: WebWorkerRequest, cb: () => Promise<any>) {\n        let queryResult: Promise<any>;\n        const query = request.query;\n        const ctx = this;\n        const idbutil = ctx.util;\n        const callAPI = (api: typeof Select, beforeExecute?: () => Promise<any>) => {\n            queryResult = new api(query, idbutil).\n                execute(beforeExecute);\n        };\n        switch (request.name) {\n            case API.OpenDb:\n                cb();\n                queryResult = ctx.openDb(query);\n                break;\n            case API.InitDb:\n                cb();\n                queryResult = ctx.initDb(query);\n                break;\n            case API.CloseDb:\n                cb();\n                queryResult = ctx.closeDb();\n                break;\n            case API.Insert:\n                callAPI(Insert as any, cb);\n                break;\n            case API.Select:\n                callAPI(Select as any, cb);\n                break;\n            case API.Count:\n                callAPI(Count as any, cb);\n                break;\n            case API.Update:\n                callAPI(Update as any, cb);\n                break;\n            case API.Intersect:\n                cb();\n                callAPI(Intersect as any);\n                break;\n            case API.DropDb:\n                cb();\n                queryResult = ctx.dropDb();\n                break;\n            case API.Terminate:\n                cb();\n                queryResult = ctx.terminate();\n                break;\n            case API.Union:\n                cb();\n                callAPI(Union as any);\n                break;\n            case API.Remove:\n                callAPI(Remove as any, cb);\n                break;\n            case API.Clear:\n                callAPI(Clear as any, cb);\n                break;\n            case API.Transaction:\n                callAPI(Transaction as any, cb);\n                break;\n            case API.MapGet:\n                cb();\n                queryResult = MetaHelper.get(query as string, idbutil);\n                break;\n            case API.MapSet:\n                cb();\n                queryResult = MetaHelper.set(query.key, query.value, idbutil);\n                break;\n            case API.MapHas:\n                cb();\n                queryResult = MetaHelper.has(query as string, idbutil);\n                break;\n            case API.MapDelete:\n                cb();\n                queryResult = MetaHelper.remove(query as string, idbutil);\n                break;\n            case API.ImportScripts:\n                cb();\n                queryResult = ctx.importScripts_(request);\n                break;\n            case API.ChangeLogStatus:\n                cb();\n                ctx.logger.status = query;\n                queryResult = Promise.resolve();\n                break;\n            case API.Middleware:\n                cb();\n                const value = variableFromPath(query);\n                if (!value) {\n                    return promiseReject(\n                        new LogHelper(ERROR_TYPE.InvalidMiddleware, query)\n                    );\n                }\n                ctx.middlewares.push(query);\n                return promiseResolve();\n            default:\n                if (process.env.NODE_ENV !== 'production') {\n                    console.error('The Api:-' + request.name + ' does not support.');\n                }\n                queryResult = promiseResolve();\n        }\n        ctx.logger.log(`Executing query ${request.name} in web worker`);\n        return queryResult;\n    }\n\n    private callMiddleware_(middlewares: any[], result?) {\n        return promise<any>((res) => {\n            let index = 0;\n            const lastIndex = (getLength(middlewares) as any) - 1;\n            const callNextMiddleware = () => {\n                if (index <= lastIndex) {\n                    let promiseResult = middlewares[index++](result);\n                    if (!(promiseResult instanceof Promise)) {\n                        promiseResult = promiseResolve(promiseResult);\n                    }\n                    promiseResult.then(modifiedResult => {\n                        result = modifiedResult;\n                        callNextMiddleware();\n                    });\n                }\n                else {\n                    res(result);\n                }\n            };\n            callNextMiddleware();\n        });\n    }\n\n    run(request: WebWorkerRequest) {\n        let onResultCallback = [];\n        const beforeExecuteCallback = [];\n        request.onResult = (cb) => {\n            onResultCallback.push((result) => {\n                return cb(result);\n            });\n        };\n        request.beforeExecute = (cb) => {\n            beforeExecuteCallback.push((result) => {\n                return cb(result);\n            });\n        };\n        this.executeMiddleware_(request).then(_ => {\n            return this.executeQuery(request, () => {\n                return this.callMiddleware_(beforeExecuteCallback);\n            }).then((result) => {\n                return this.callMiddleware_(onResultCallback, result).then(modifiedResult => {\n                    this.returnResult_({\n                        result: modifiedResult\n                    });\n                });\n            });\n        }).catch(ex => {\n            onResultCallback = [];\n            const err = getError(ex);\n            const result = {\n                error: err\n            } as WebWorkerResult;\n            this.returnResult_(result);\n        });\n    }\n\n    private importScripts_(request: WebWorkerRequest) {\n        return promise<void>((res, rej) => {\n            try {\n                importScripts(...request.query);\n                res();\n            } catch (e) {\n                const err = new LogHelper(ERROR_TYPE.ImportScriptsFailed, e.message);\n                rej(err);\n            }\n        });\n    }\n\n    private returnResult_(result: WebWorkerResult) {\n        this.logger.log(`Query finished inside web worker`);\n        if (this.util) {\n            this.util.emptyTx();\n        }\n        this.onQryFinished(result);\n    }\n\n    private dropDb() {\n        const dbName = this.db.name;\n        return this.terminate().then(() => {\n            return new DropDb().execute(dbName);\n        });\n    }\n\n    closeDb() {\n        return this.util.close();\n    }\n\n    terminate() {\n        return this.closeDb().then(() => {\n            this.util.db = null;\n        });\n    }\n\n    openDb(query: IDbInfo) {\n        return this.closeDb().then(_ => {\n            let pResult: Promise<InitDbResult>;\n            if (this.db && query.name === this.db.name) {\n                pResult = this.initDb();\n            }\n            else {\n                pResult = this.initDb({\n                    name: query.name,\n                    tables: [\n                    ],\n                    version: query.version\n                });\n            }\n            return pResult.then(() => {\n                return this.db;\n            });\n        });\n    }\n\n    initDb(dataBase?: IDataBase) {\n        if (!IS_IDB_SUPPORTED) {\n            return promiseReject(\n                new LogHelper(ERROR_TYPE.IndexedDbNotSupported)\n            );\n        }\n\n        const dbMeta = dataBase ? new DbMeta(dataBase) : this.db;\n        if (dbMeta == null) {\n            throw new Error(`dbMeta is null`);\n        }\n        this.util = new IDBUtil();\n\n        return this.util.initDb(dbMeta).then(dbInfo => {\n            return MetaHelper.get(\n                MetaHelper.dbSchema,\n                this.util\n            ).then((dbFromCache: DbMeta) => {\n                if (dbInfo.isCreated) {\n                    if (dbFromCache) {\n                        dbFromCache.tables.forEach((tableFromCache) => {\n                            const targetTable = dbMeta.tables.find(q => q.name === tableFromCache.name);\n                            if (targetTable) {\n                                for (const key in tableFromCache.autoIncColumnValue) {\n                                    const savedAutoIncrementValue = tableFromCache.autoIncColumnValue[key];\n                                    if (savedAutoIncrementValue) {\n                                        targetTable.autoIncColumnValue[key] = savedAutoIncrementValue;\n                                    }\n                                }\n                            }\n                        });\n                    }\n                    this.util.db = dbMeta;\n                    dbInfo.database = userDbSchema(this.db);\n                    return MetaHelper.set(\n                        MetaHelper.dbSchema,\n                        dbMeta,\n                        this.util\n                    ).then(() => {\n                        return dbInfo;\n                    });\n                }\n                else {\n                    return MetaHelper.get(\n                        MetaHelper.dbSchema,\n                        this.util\n                    ).then((value: any) => {\n                        this.util.db = value;\n                        dbInfo.database = userDbSchema(this.db);\n                        return dbInfo;\n                    });\n                }\n            });\n        });\n    }\n}\n","import { QueryManager } from \"@/worker/query_manager\";\nimport { IS_WORKER } from \"./constants\";\nexport * from \"./query_manager\";\n\nif (IS_WORKER) {\n    const manager = new QueryManager();\n    (self as any).onmessage = function (e) {\n        manager.run(e.data);\n    };\n}\n\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","WORKER_STATUS","DATA_TYPE","API","EVENT","QUERY_OPTION","IDB_MODE","OCCURENCE","CONNECTION_STATUS","promiseResolve","Promise","resolve","promise","cb","ERROR_TYPE","table","columns","autoIncColumnValue","this","setColumn","name","alter","tableColumns","columnName","column","autoIncrement","primaryKey","keypath","keyPath","enableSearch","existingColumnIndex","indexOf","q","push","existingColumn","assign","autoIncrementKey","tableName","getStore","util","tx","createTransaction","MetaHelper","objectStore","set","store","res","rej","req","put","onsuccess","onerror","keyRange","result","remove","delete","has","count","dbSchema","db","version","tables","map","TableMeta","forObj","type","info","info_","message","getMsg_","log","msg","status","console","throw","logError","error","warn","errMsg","errorHandler","getInfo","errorType","method","logger","LogHelper","emptyTx","oncomplete","onabort","createTransactionIfNotExist","mode","ReadWrite","con","transaction","op","Between","IDBKeyRange","bound","low","high","GreaterThan","lowerBound","GreaterThanEqualTo","LessThan","upperBound","LessThanEqualTo","only","abortTransaction","abort","close","setTimeout","initDb","oldVersion","isDbCreated","dbVersion","dbOpenRequest","indexedDB","open","onversionchange","e","target","isCreated","newVersion","onupgradeneeded","upgradeConnection","storeNames","objectStoreNames","addColumn","indexNames","contains","options","unique","multiEntry","createIndex","deleteColumn","index","findIndex","splice","deleteIndex","forEach","option","createObjectStore","i","alterQuery","add","drop","modify","shouldDelete","targetColumn","find","newColumn","storeName","item","qry","deleteObjectStore","length","promiseAll","promises","all","promiseReject","reject","getError","rowAffected","isTxQuery","results","query","from","meta","getColumnInfo","onException","ex","getErrorFromException","getDataType","Null","Array","isArray","Date","DateTime","isNull","isNaN","autoIncValues","autoIncrementValue","checkAndModifyValues","err","values","ignoreIndexes","every","checkAndModifyValue","ignore","checkAndModifyColumnValue_","checkNotNullAndDataType_","notNull","ColumnName","dataType","receivedType","expected","received","columnValue","Number","undefined","default","validation","details","check","setValue","tblName","checkByColumn_","checkFurther","allowedOp","validate","api","Select","Remove","Count","checkSelect","Insert","checkInsertQuery","Update","checkUpdate","getTable_","isInsertQryValid","into","SchemaChecker","in","where","checkForNullInWhere_","addGreatAndLessToNotOp_","whereQuery","containsNot","keys","NotEqualTo","addToSingleQry","Or","queryKeys","qryKeys","validResult","skipDataCheck","ValuesChecker","valuesAffected_","execute","beforeInsert","QueryHelper","then","_","insertData_","return","catch","onInsertData","addMethod","idbMethod","upsert","addResult","Base","IS_WORKER","self","alert","ServiceWorkerGlobalScope","IS_IDB_SUPPORTED","mozIndexedDB","webkitIndexedDB","msIndexedDB","IDBTransaction","webkitIDBTransaction","msIDBTransaction","webkitIDBKeyRange","msIDBKeyRange","setCrossBrowserIndexedDb","getKeys","getLength","setCaseAndValue","caseQuery","caseQuery_","setCaseAndColumn","columnName_","caseColumnQuery_","length_","evaluate","checkCase_","lastThen","cond","queryOption","Equal","getCursorOnSuccess","simpleFn","limitFn","skipFn","skipAndLimitFn","limitAtEnd","skipAtEnd","skipRecord","limitRecord","executeSkipAndLimitForWhere_","onFinish","recordSkipped","cursor","shouldAddValue","pushResult","continue","advance","executeSkipForWhere_","executeLimitForWhere_","executeSimpleForWhere_","executeSkipAndLimit","onFinished","executeSkip","executeSimple","executeLimit","removeSpace","replace","getOrderColumnInfo","orderColumn","join","splittedByDot","split","joinOrderColumn","valueFromFirstColumn","isOrder","compareStringInDesc_","a","b","localeCompare","compareStringinAsc_","compareDefaultInDesc_","String","compareDefaultinAsc_","compareNumberInDesc_","compareNumberinAsc_","compareDateInDesc_","getTime","compareDateInAsc_","getValueComparer_","order","orderBy_","getOrderType_","by","thenEvaluator","getValInAscDesc","stringComparer","numberComparer","value1","value2","column1","column2","sortMethod","sort","columnInfo","case","toLowerCase","getObjectFirstKey","getRegexFromLikeExpression","likeExpression","filterValue","occurence","filterValues","Any","Last","First","RegExp","clone","copy","compare","compareValue","symbol","type1","checkFlag","props","last","pop","reduce","prev","curr","rowValue","whereColumnValue","isArrayColumnValue","isArrayWhereColumnValue","executeCompare","executor","In","checkIn","Like","checkLike_","Regex","checkRegex","checkComparisionOp_","storedValue","test","goToWhereLogic","firstColumn","whereChecker","WhereChecker","executeWhereLogic","regexVal","executeRegexLogic","executeInLogic","Aggregate","skipOrPush","select","joinQueryStack_","currentQueryStackIndex_","tablesFetched","getTable","executeSelect","tablesToFetch","joinQueryStack","jointblInfo","getJoinTableInfo_","on","with","table1","table2","checkJoinQuery_","joinTableInfo","whereQryParam","whereQryAfterJoin","filter","isWhereEmpty","filteredOr","whereQryOr","orColumn","whereQueryModified","removeJoinColumnResult","joinQuery","flatten","startExecutingJoinLogic_","onJoinQueryFinished_","selectApi","data","setLimitAndSkipEvaluationAtEnd_","processOrderBy","jointables","secondtableData","valueMatchedFromSecondTable","joinerComparer","defaultValueSetter","columnDefaultValue","joinType","output","table1Index","table2Index","asQuery","as","mapWithAlias","asValue","val","whereQry","whereCheker","col","valueFromSecondTable","valueFromFirstTable","joinOn","splittedjoinOn","splittedjoinOnbydotFirst","splittedjoinOnbydotSecond","tableSchemaOf1stTable","tableSchemaOf2ndTable","columnFound","whereJoinParam","whereForExtraColumn","openCursor","cursorRequest","callOnSuccess","includes","sorted","isSubQuery","ThenEvaluator","returnResult_","Map","concat","processGroupDistinctAggr","skip","slice","limit","setPushResult","isArrayQry","orderQuery","groupBy","beforeExecute","initTransaction_","processWhereArrayQry","processWhere_","executeWhereUndefinedLogic","executeJoinQuery","bind","operation","pKey","isFirstWhere","onSuccess","andResults","And","keyValue","mergeWithResults","processFirstQry","executeWhere","whereQueryToProcess","shift","whereQueryOr","MemoryObjectStore","ReadOnly","cursorValue","that","proxy","Proxy","p","receiver","or","processOrLogic_","onWhereEvaluated","isOr","orQuerySuccess_","orInfo","orQuery","BaseFetch","isWhereKeysLengthOne","idbSorting","orderType","dir","exp","datas","lookupObject","Join","distinct","aggregate","executeAggregateGroupBy","processGroupBy","processAggregateQry","orderQueryType","prevOrderQueryBy","currentOrderQuery","currentorderQueryBy","orderColumnDetail","columnToAggregate","datasLength","getCount","getMax","getMin","Infinity","getSum","getAvg","aggregateQry","aggregateColumn","aggregateValType","aggregateCalculator","objKey","grpQry","lookUpObj","calculateAggregate","getList","sumOfColumn","Max","Min","Sum","Avg","List","avgQuery","avg","sumForAvg","countForAvg","sum","isCountTypeString","isSumTypeString","avgColumn","groupByDataType","groupByColumn","onWhereCount","resultCount","queryHelper","getDataFromSelect","selectInstance","countRequest","isWhereKeysLengthOneValue","columnStore","variableFromPath","path","updateValue","mapSet","columnSetValue","returnImmediate","txPromise","initTransaction","promiseToUse","executeComplexLogic_","selectObject","ignoreCase","inQuery","cursorUpdateRequest","update","cursorOpenRequest","intersectQry","getHashKey","hashMap","hashMapTemp","isQueryForSameTable","queries","queryLength","columnValKey","fetchData","selectResult","resultPusher","callBack","dbName","dropDbRequest","deleteDatabase","onblocked","onWhereRemove","pResult","keyList","pkey","Where","processOrLogic","orQueryFromOrInfo","_orInfo","OrQuery","columnIndex","clearRequest","clear","currentTable","reqQueue","isQueryExecuting","isTxStarted_","startExecution_","onError","notExistingTable","notExistingTable_","methodName","createPusher","pushReq_","txLogic","insert","setResult","getResult","abortTx_","start","startTx_","tableNames","processExecutionOfQry_","onReqFinished_","finisehdRequest","executeRequest_","request","requestObj","onReqFinished","callAPI","promiseObj","invalidTable","userDbSchema","Error","database","tableAsObj","fn","middlewares","IDBUtil","onQryFinished","postMessage","executeMiddleware_","lastIndex","middlewareContext","callNextMiddleware","promiseResult","executeQuery","queryResult","ctx","idbutil","OpenDb","openDb","InitDb","CloseDb","closeDb","Intersect","DropDb","dropDb","Terminate","terminate","Union","Clear","Transaction","MapGet","MapSet","MapHas","MapDelete","ImportScripts","importScripts_","ChangeLogStatus","Middleware","callMiddleware_","modifiedResult","run","onResultCallback","beforeExecuteCallback","onResult","importScripts","dataBase","dbMeta","DbMeta","dbInfo","dbFromCache","tableFromCache","targetTable","savedAutoIncrementValue","QueryManager","onmessage"],"sourceRoot":""}